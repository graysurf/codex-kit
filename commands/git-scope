#!/usr/bin/env -S zsh -f
set -e

# Bundled from: ~/.config/zsh/cache/wrappers/bin/git-scope
: "${ZDOTDIR:=$HOME/.config/zsh}"
export ZDOTDIR
export ZSH_CONFIG_DIR="${ZSH_CONFIG_DIR:-$ZDOTDIR/config}"
export ZSH_BOOTSTRAP_SCRIPT_DIR="${ZSH_BOOTSTRAP_SCRIPT_DIR:-$ZDOTDIR/bootstrap}"
export ZSH_SCRIPT_DIR="${ZSH_SCRIPT_DIR:-$ZDOTDIR/scripts}"

# --- BEGIN _internal/wrappers.bundle-prelude.zsh
# Wrapper runtime prelude for bundled cached CLI wrappers.
#
# This file is intended to be *inlined* into generated wrapper binaries under:
#   $ZSH_CACHE_DIR/wrappers/bin/*
#
# It should remain safe to execute (no top-level `return`), and it should not
# depend on any other files at runtime.

# bundle-wrapper.zsh emits `set -e`; disable it to match the previous wrapper behavior.
set +e

typeset wrapper_bin="${0:A:h}"
[[ -d "$wrapper_bin" ]] && export PATH="$wrapper_bin:$PATH"

typeset wrapper_cache_dir="${wrapper_bin:h:h}"
export ZSH_CACHE_DIR="${ZSH_CACHE_DIR:-$wrapper_cache_dir}"
export ZSH_COMPDUMP="${ZSH_COMPDUMP:-$ZSH_CACHE_DIR/.zcompdump}"

[[ -d "$ZSH_CACHE_DIR" ]] || mkdir -p -- "$ZSH_CACHE_DIR"


# --- END _internal/wrappers.bundle-prelude.zsh

# --- BEGIN ~/.config/zsh/bootstrap/00-preload.zsh
# safe_unalias [-v] <name...>
# Safely remove one or more aliases without causing errors.
#
# This utility function checks whether each given name is an existing alias,
# and only unaliases it if it exists. This avoids "no such hash table element"
# errors when running scripts that are sourced multiple times or across environments.
#
# It also supports an optional `-v` flag to enable verbose output for debugging.
#
# Usage:
#   safe_unalias foo bar       # Silently unalias 'foo' and 'bar' if they exist
#   safe_unalias -v foo bar    # Verbosely unalias 'foo' and 'bar'
#
# Notes:
# - This function is meant to be defined early in the shell environment,
#   so it can be reused safely in all scripts.
# - It only affects aliases (not functions or commands).
safe_unalias() {
  typeset verbose=false
  typeset first_arg="${1-}"

  if [[ "$first_arg" == "-v" ]]; then
    verbose=true
    shift
  fi

  for name in "$@"; do
    if alias "$name" &>/dev/null; then
      $verbose && printf "ğŸ” Unaliasing %s\n" "$name"
      unalias "$name"
    fi
  done

  return 0
}

# get_clipboard
# Read clipboard contents and print to stdout.
# Usage: get_clipboard
# Notes:
# - Requires pbpaste (macOS) or xclip/xsel (Linux).
get_clipboard() {
  if command -v pbpaste >/dev/null 2>&1; then
    pbpaste
  elif command -v xclip >/dev/null 2>&1; then
    xclip -selection clipboard -o
  elif command -v xsel >/dev/null 2>&1; then
    xsel --clipboard --output
  else
    printf "âŒ No clipboard tool found (requires pbpaste, xclip, or xsel)\n" >&2
    return 1
  fi
}

# set_clipboard
# Read stdin and write it to the system clipboard.
# Usage: <command> | set_clipboard
# Notes:
# - Requires pbcopy (macOS) or xclip/xsel (Linux).
set_clipboard() {
  if command -v pbcopy >/dev/null 2>&1; then
    pbcopy
  elif command -v xclip >/dev/null 2>&1; then
    xclip -selection clipboard -i
  elif command -v xsel >/dev/null 2>&1; then
    xsel --clipboard --input
  else
    printf "âŒ No clipboard tool found (requires pbcopy, xclip, or xsel)\n" >&2
    return 1
  fi
}

if [[ -z ${_ZSH_BOOTSTRAP_PRELOAD_PATH+1} ]]; then
  typeset -gr _ZSH_BOOTSTRAP_PRELOAD_PATH="${(%):-%N}"
fi

# progress_bar::load
# Load the progress bar implementation (scripts/progress-bar.zsh) on demand.
# Usage: progress_bar::load
# Notes:
# - This is a bootstrap-time shim so cached CLI wrappers (which bundle 00-preload.zsh) can use it.
# - Returns non-zero when the module file is missing/unreadable.
progress_bar::load() {
  emulate -L zsh

  if (( ${+functions[_progress_bar::build_bar]} )); then
    typeset -g _ZSH_PROGRESS_BAR_LOADED=1
    return 0
  fi

  typeset zdotdir="${ZDOTDIR-}"
  if [[ -z "$zdotdir" ]]; then
    typeset preload_path="${_ZSH_BOOTSTRAP_PRELOAD_PATH-}"
    if [[ -n "$preload_path" ]]; then
      preload_path="${preload_path:A}"
      zdotdir="${preload_path:h:h}"
    fi
  fi
  [[ -n "$zdotdir" ]] || zdotdir="$HOME/.config/zsh"

  typeset script_dir="${ZSH_SCRIPT_DIR:-$zdotdir/scripts}"
  typeset target="$script_dir/progress-bar.zsh"

  [[ -r "$target" ]] || return 1
  source "$target" || return 1

  (( ${+functions[_progress_bar::build_bar]} )) && return 0
  return 1
}

# progress_bar::init
# Bootstrap shim for progress_bar::init (determinate progress bar).
# Usage: progress_bar::init <id> --prefix <text> --total <n> [--width <n>] [--head-len <n>] [--fd <n>] [--enabled|--disabled]
progress_bar::init() { progress_bar::load || return $?; progress_bar::init "$@"; }

# progress_bar::update
# Bootstrap shim for progress_bar::update (determinate progress bar).
# Usage: progress_bar::update <id> <current> [--suffix <text>] [--force]
progress_bar::update() { progress_bar::load || return $?; progress_bar::update "$@"; }

# progress_bar::finish
# Bootstrap shim for progress_bar::finish (determinate progress bar).
# Usage: progress_bar::finish <id> [--suffix <text>]
progress_bar::finish() { progress_bar::load || return $?; progress_bar::finish "$@"; }

# progress_bar::init_indeterminate
# Bootstrap shim for progress_bar::init_indeterminate (indeterminate progress bar).
# Usage: progress_bar::init_indeterminate <id> --prefix <text> [--width <n>] [--head-len <n>] [--fd <n>] [--enabled|--disabled]
progress_bar::init_indeterminate() { progress_bar::load || return $?; progress_bar::init_indeterminate "$@"; }

# progress_bar::tick
# Bootstrap shim for progress_bar::tick (advance indeterminate progress bar).
# Usage: progress_bar::tick <id> [--suffix <text>] [--force]
progress_bar::tick() { progress_bar::load || return $?; progress_bar::tick "$@"; }

# progress_bar::stop
# Bootstrap shim for progress_bar::stop (clear indeterminate progress bar line).
# Usage: progress_bar::stop <id>
progress_bar::stop() { progress_bar::load || return $?; progress_bar::stop "$@"; }

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Env helpers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if [[ -z ${_ZSH_ENV_BOOL_INVALID_WARNED+1} ]]; then
  typeset -gA _ZSH_ENV_BOOL_INVALID_WARNED=()
fi

# zsh_env::is_true <value> [name]
# Return 0 when the input value is `true` (case-insensitive).
#
# Rules:
# - Only `true` and `false` are accepted.
# - Empty/unset: treated as false (no warning).
# - Invalid (non-empty, not true/false): warn once to stderr and treat as false.
zsh_env::is_true() {
  emulate -L zsh
  setopt pipe_fail nounset

  typeset raw="${1-}"
  [[ -n "$raw" ]] || return 1

  typeset name="${2-}"
  typeset lowered="${raw:l}"
  case "$lowered" in
    true) return 0 ;;
    false) return 1 ;;
    *)
      if [[ -n "$name" && -z "${_ZSH_ENV_BOOL_INVALID_WARNED[$name]-}" ]]; then
        _ZSH_ENV_BOOL_INVALID_WARNED[$name]=1
        print -u2 -r -- "warning: ${name} must be true|false (got: ${raw}); treating as false"
      elif [[ -z "$name" ]]; then
        print -u2 -r -- "warning: invalid boolean value (expected true|false; got: ${raw}); treating as false"
      fi
      return 1
      ;;
  esac
}

# --- END ~/.config/zsh/bootstrap/00-preload.zsh

# --- BEGIN git/git-scope.zsh
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Aliases and Unalias
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if command -v safe_unalias >/dev/null; then
  safe_unalias gs gsc gst
fi

# gs
# Alias of `git-scope`.
# Usage: gs <command> [args...]
alias gs='git-scope'

# gsc
# Alias of `git-scope commit`.
# Usage: gsc <commit-ish> [--parent <n>] [-p|--print]
alias gsc='git-scope commit'

# gst
# Alias of `git-scope tracked`.
# Usage: gst [prefix...]
alias gst='git-scope tracked'

_git_scope_no_color=false
typeset -ga _git_scope_commit_file_list=()

# _git_scope_kind_color <A|M|D|U|->
# Return ANSI color code for a file change kind.
# Usage: _git_scope_kind_color <A|M|D|U|->
_git_scope_kind_color() {
  if [[ "$_git_scope_no_color" == true ]]; then
    return 0
  fi

  case "$1" in
    A) printf '\033[38;5;66m'  ;;  # Added    â†’ #3d6f6f (Delta plus-style)
    M) printf '\033[38;5;110m' ;;  # Modified â†’ #add6ff (Delta file-style)
    D) printf '\033[38;5;95m'  ;;  # Deleted  â†’ #5a3e39 (Delta minus-style)
    U) printf '\033[38;5;110m' ;;  # Unknown  â†’ fallback Owl Blue (#82aaff)
    -) printf '\033[0m'        ;;  # Reset
    *) printf '\033[38;5;110m' ;;  # Fallback
  esac
}

# _git_scope_color_reset
# Print ANSI reset code (no-op when no-color is enabled).
# Usage: _git_scope_color_reset
_git_scope_color_reset() {
  if [[ "$_git_scope_no_color" == true ]]; then
    return 0
  fi

  printf '\033[0m'
}

# _git_scope_render_tree <newline_separated_paths>
# Render a directory tree from a list of file paths.
# Usage: _git_scope_render_tree <newline_separated_paths>
_git_scope_render_tree() {
  typeset -a file_list=("${(@f)}$1")

  if [[ "${#file_list[@]}" -eq 0 ]]; then
    printf "âš ï¸ No files to render as tree\n"
    return 1
  fi

  printf "\nğŸ“‚ Directory tree:\n"

  typeset -a tree_args=(--fromfile)
  typeset strip_color=false
  if [[ "$_git_scope_no_color" == true ]]; then
    strip_color=true
  else
    tree_args+=(-C)
  fi

  if [[ "$strip_color" == true ]]; then
    printf "%s\n" "${file_list[@]}" | awk -F/ '{
      path=""
      for(i=1;i<NF;i++) {
        path = (path ? path "/" $i : $i)
        print path
      }
      print $0
    }' | sort -u | command tree "${tree_args[@]}" | sed 's/\x1b\[[0-9;]*m//g'
  else
    printf "%s\n" "${file_list[@]}" | awk -F/ '{
      path=""
      for(i=1;i<NF;i++) {
        path = (path ? path "/" $i : $i)
        print path
      }
      print $0
    }' | sort -u | command tree "${tree_args[@]}"
  fi
}


# _git_scope_render_with_type <name_status_lines>
# Render `git diff --name-status`-style lines and show a directory tree.
# Usage: _git_scope_render_with_type <name_status_lines>
_git_scope_render_with_type() {
  typeset input="$1"

  if [[ -z "$input" ]]; then
    printf "âš ï¸  No matching files\n"
    return 1
  fi

  typeset color_reset="$(_git_scope_color_reset)"
  typeset -a files=()

  printf "\nğŸ“„ Changed files:\n"

  while IFS=$'\t' read -r kind src dest; do
    [[ -z "$src" ]] && continue

    typeset display_path="$src"
    typeset file_path="$src"
    if [[ ( "$kind" == R* || "$kind" == C* ) && -n "$dest" ]]; then
      display_path="${src} -> ${dest}"
      file_path="$dest"
    fi

    files+=("$file_path")
    typeset color="$(_git_scope_kind_color "$kind")"
    printf "  %bâ” [%s] %s%b\n" "$color" "$kind" "$display_path" "$color_reset"
  done <<< "$input"

  _git_scope_render_tree "${(F)files}"

  if [[ "$_git_scope_should_print" == true ]]; then
    printf "\nğŸ“¦ Printing file contents:\n"
    for file in "${files[@]}"; do
      print_file_content "$file"
      printf "\n"
    done
  fi
}


# _git_scope_collect <mode> [args...]
# Collect file lists for `git-scope` subcommands.
# Usage: _git_scope_collect <tracked|staged|unstaged|all|untracked|commit> [args...]
_git_scope_collect() {
  typeset mode="$1"
  (( $# > 0 )) && shift

  typeset -a args=()
  _git_scope_should_print=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -p|--print) _git_scope_should_print=true ;;
      *) args+=("$1") ;;
    esac
    (( $# > 0 )) && shift
  done

  case "$mode" in
    staged)
      git -c core.quotepath=false diff --cached --name-status --diff-filter=ACMRTUXB ;;
    unstaged)
      git -c core.quotepath=false diff --name-status --diff-filter=ACMRTUXB ;;
    all)
      printf "%s\n%s" \
        "$(git -c core.quotepath=false diff --cached --name-status --diff-filter=ACMRTUXB)" \
        "$(git -c core.quotepath=false diff --name-status --diff-filter=ACMRTUXB)" \
        | grep -v '^$' | sort -u ;;
    tracked)
      typeset -a prefixes=("${args[@]}")
      typeset files='' all_filtered=''
      files=$(git -c core.quotepath=false ls-files)
      if [[ ${#prefixes[@]} -gt 0 ]]; then
        for prefix in "${prefixes[@]}"; do
          clean_prefix="${prefix%/}"
          if [[ -d "$clean_prefix" ]]; then
            all_filtered+=$'\n'$(printf '%s\n' "$files" | grep "^${clean_prefix}/")
          elif [[ -f "$clean_prefix" ]]; then
            all_filtered+=$'\n'$(printf '%s\n' "$files" | grep -x "$clean_prefix")
          else
            all_filtered+=$'\n'$(printf '%s\n' "$files" | grep "^${clean_prefix}")
          fi
        done
        files="$(printf '%s\n' "$all_filtered" | grep -v '^$' | sort -u)"
      fi
      printf '%s\n' "$files" | while IFS= read -r f; do
        [[ -n "$f" ]] && printf "-\t%s\n" "$f"
      done ;;
    untracked)
      git -c core.quotepath=false ls-files --others --exclude-standard | while IFS= read -r f; do
        [[ -n "$f" ]] && printf "U\t%s\n" "$f"
      done ;;
    commit)
      typeset commit="${args[1]}"
      git -c core.quotepath=false show --pretty=format: --name-status "$commit" ;;
    *)
      printf "âš ï¸ Unknown collect mode: %s\n" "$mode" >&2
      return 1 ;;
  esac
}

# print_file_content <path>
# Print file contents from working tree, or fallback to `HEAD:<path>` when missing locally.
# Usage: print_file_content <path>
print_file_content() {
  typeset file="$1"

  if [[ -z "$file" ]]; then
    printf "â— Missing file path\n"
    return 1
  fi

  if [[ -f "$file" ]]; then
    if file --mime "$file" | grep -q 'charset=binary'; then
      printf "ğŸ“„ %s (binary file in working tree)\n" "$file"
      printf "ğŸ”¹ [Binary file content omitted]\n"
    else
      printf "ğŸ“„ %s (working tree)\n" "$file"
      printf '```\n'
      cat -- "$file"
      printf '\n```\n'
    fi
  elif git cat-file -e "HEAD:$file" 2>/dev/null; then
    typeset tmp=''
    tmp="$(mktemp 2>/dev/null || true)"
    if [[ -z "$tmp" ]]; then
      tmp="$(mktemp -t git-scope.XXXXXX 2>/dev/null || true)"
    fi
    [[ -n "$tmp" ]] || {
      printf "â— Failed to create temp file\n"
      return 1
    }
    git show "HEAD:$file" > "$tmp"

    if file --mime "$tmp" | grep -q 'charset=binary'; then
      printf "ğŸ“„ %s (binary file in HEAD)\n" "$file"
      printf "ğŸ”¹ [Binary file content omitted]\n"
    else
      printf "ğŸ“„ %s (from HEAD)\n" "$file"
      printf '```\n'
      cat -- "$tmp"
      printf '\n```\n'
    fi

    rm -f "$tmp"
  else
    printf "â— File not found: %s\n" "$file"
    return 1
  fi
}

# Command handlers
# _git_scope_tracked: Handler for `git-scope tracked`.
_git_scope_tracked()   { _git_scope_render_with_type "$(_git_scope_collect tracked "$@")"; }
# _git_scope_staged: Handler for `git-scope staged`.
_git_scope_staged()    { _git_scope_render_with_type "$(_git_scope_collect staged "$@")"; }
# _git_scope_unstaged: Handler for `git-scope unstaged`.
_git_scope_unstaged()  { _git_scope_render_with_type "$(_git_scope_collect unstaged "$@")"; }
# _git_scope_all: Handler for `git-scope all`.
_git_scope_all()       { _git_scope_render_with_type "$(_git_scope_collect all "$@")"; }
# _git_scope_untracked: Handler for `git-scope untracked`.
_git_scope_untracked() { _git_scope_render_with_type "$(_git_scope_collect untracked "$@")"; }

# _git_scope_commit - Show detailed information of a git commit
#
# Unlike other git-scope commands (e.g., `staged`, `tracked`), which operate
# on the working directory or index, this command analyzes a historical commit
# and renders its metadata, commit message, changed files, and optionally
# prints the file contents if they are retrievable from HEAD or working tree.
#
# Features:
#   â€¢ Displays commit hash, author, date, and message with formatting
#   â€¢ Parses both name-status and numstat to show per-file diff counts
#   â€¢ Computes total lines added and deleted across all files
#   â€¢ Renders affected directory structure using `tree --fromfile`
#   â€¢ Supports `-p` to print file contents (text or binary placeholder)
#
# Usage:
#   git-scope commit <commit-ish> [-p]
#
# Example:
#   git-scope commit HEAD~1         # Show summary of an old commit
#   git-scope commit a1b2c3 -p      # Show and print files changed in a commit
#
# Note:
#   Internally, it isolates display output from file path data, ensuring
#   clean separation of UI and logic. It uses a shared in-memory list to pass
#   changed file paths from the rendering function back to the dispatcher.
#
# This command is especially useful for code review, audit trails, or
# inspecting past changes in high detail.
_git_scope_commit() {
  emulate -L zsh
  setopt pipe_fail

  typeset parent_selector=''
  typeset -a positional=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --parent|-P)
        if [[ $# -lt 2 ]]; then
          printf "â— --parent requires an argument\n"
          return 1
        fi
        parent_selector="$2"
        shift 2
        continue
        ;;
      --parent=*)
        parent_selector="${1#*=}"
        ;;
      -P*)
        parent_selector="${1#-P}"
        ;;
      *)
        positional+=("$1")
        ;;
    esac
    shift
  done

  typeset commit="${positional[1]}"
  if [[ -z "$commit" ]]; then
    printf "â— Usage: git-scope commit <commit-hash | HEAD> [--parent <n>]\n"
    return 1
  fi

  _git_scope_print_commit_metadata "$commit"
  _git_scope_print_commit_message "$commit"
  _git_scope_render_commit_files "$commit" "$parent_selector"

  typeset -a file_list=()
  file_list=("${_git_scope_commit_file_list[@]}")

  if [[ "$_git_scope_should_print" == true ]]; then
    printf "\nğŸ“¦ Printing file contents:\n"
    for file in "${file_list[@]}"; do
      print_file_content "$file"
      printf "\n"
    done
  fi
}

# Print commit header info (hash, author, date)
_git_scope_print_commit_metadata() {
  typeset commit="$1"

  printf "\n"
  if [[ "$_git_scope_no_color" == true ]]; then
    git log -1 --color=never --date=format:'%Y-%m-%d %H:%M:%S %z' \
      --pretty=format:"ğŸ”– %h %s%nğŸ‘¤ %an <%ae>%nğŸ“… %ad" "$commit"
  else
    git log -1 --date=format:'%Y-%m-%d %H:%M:%S %z' \
      --pretty=format:"ğŸ”– %C(bold #82aaff)%h%C(reset) %C(#d6deeb)%s%C(reset)%nğŸ‘¤ %C(#7fdbca)%an%C(reset) <%C(#d6deeb)%ae%C(reset)>%nğŸ“… %C(#ecc48d)%ad%C(reset)" "$commit"
  fi
}

# Pretty print commit message body
_git_scope_print_commit_message() {
  typeset commit="$1"

  printf "\n\nğŸ“ Commit Message:\n"
  git log -1 --pretty=format:%B "$commit" | awk '
    NR == 1 { print "   "$0; next }
    length($0) == 0 { print "" ; next } 
    { print "   "$0 }'
}

# Render file change list with color and stats
_git_scope_commit_parents() {
  emulate -L zsh
  setopt pipe_fail

  typeset commit="$1"
  typeset parents_raw=''

  typeset -ga reply=()

  parents_raw=$(git show -s --pretty=%P "$commit") || return 1
  if [[ -z "$parents_raw" ]]; then
    reply=()
    return 0
  fi

  reply=("${(@s: :)parents_raw}")
  return 0
}

# _git_scope_render_commit_files <commit> [parent_selector]
# Render changed files for a commit (supports merge commits via parent selection).
# Usage: _git_scope_render_commit_files <commit> [parent_selector]
# Notes:
# - Writes the file list to `_git_scope_commit_file_list` for optional printing.
_git_scope_render_commit_files() {
  emulate -L zsh
  setopt pipe_fail

  typeset commit="$1"
  typeset parent_selector="$2"
  typeset -a file_list=()
  typeset -a preface_lines=()

  typeset ns_lines='' numstat_lines=''
  typeset -A numstat_by_path=()
  typeset -a parents=()
  typeset parent_count=0
  typeset is_merge=false

  _git_scope_commit_file_list=()

  _git_scope_commit_parents "$commit"
  parents=("${reply[@]}")
  parent_count=${#parents[@]}
  (( parent_count > 1 )) && is_merge=true

  typeset selected_parent_hash=''
  typeset selected_parent_short=''
  typeset selected_index=1

  if [[ "$is_merge" == true ]]; then
    if [[ -n "$parent_selector" ]]; then
      if [[ "$parent_selector" == <-> ]]; then
        selected_index=$parent_selector
      else
        preface_lines+=("  âš ï¸  Invalid --parent value '${parent_selector}' â€” falling back to parent #1")
        selected_index=1
      fi
    fi

    if (( selected_index < 1 || selected_index > parent_count )); then
      preface_lines+=("  âš ï¸  Parent index ${selected_index} out of range (1-${parent_count}) â€” falling back to parent #1")
      selected_index=1
    fi

    selected_parent_hash="$parents[$selected_index]"
    selected_parent_short=$(git rev-parse --short "$selected_parent_hash" 2>/dev/null)

    ns_lines=$(git -c core.quotepath=false diff --name-status "$selected_parent_hash" "$commit")
    numstat_lines=$(git -c core.quotepath=false diff --numstat "$selected_parent_hash" "$commit")

    if [[ -z "$ns_lines" ]]; then
      printf "\nğŸ“„ Changed files:\n"
      printf "  â„¹ï¸  Merge commit vs parent #%d (%s) has no file-level changes\n" "$selected_index" "${selected_parent_short:-$selected_parent_hash}"
      _git_scope_commit_file_list=()
      return
    fi
  else
    ns_lines=$(git show --pretty=format: --name-status "$commit")
    numstat_lines=$(git show --pretty=format: --numstat "$commit")

    if [[ -z "$ns_lines" || -z "$numstat_lines" ]]; then
      printf "\nğŸ“„ Changed files:\n"
      printf "  â„¹ï¸  No file-level changes recorded for this commit\n"
      _git_scope_commit_file_list=()
      return
    fi
  fi

  typeset total_add=0 total_del=0
  typeset color_reset="$(_git_scope_color_reset)"

  printf "\nğŸ“„ Changed files:\n"

  for line in "${preface_lines[@]}"; do
    [[ -n "$line" ]] && printf "%s\n" "$line"
  done

  if [[ "$is_merge" == true ]]; then
    printf "  â„¹ï¸  Merge commit with %d parents â€” showing diff against parent #%d (%s)\n" "$parent_count" "$selected_index" "${selected_parent_short:-$selected_parent_hash}"
  fi

  while IFS=$'\t' read -r add del raw_path; do
    [[ -z "$raw_path" ]] && continue

    typeset canonical_path="$raw_path"
    if [[ "$raw_path" == *"=>"* ]]; then
      if [[ "$raw_path" == *"{"* && "$raw_path" == *"}"* ]]; then
        typeset prefix="${raw_path%%\{*}"
        typeset after_open="${raw_path#*\{}"
        typeset inside="${after_open%%\}*}"
        typeset suffix="${after_open#*\}}"

        typeset new_part="${inside##*=> }"
        if [[ "$new_part" == "$inside" ]]; then
          new_part="${inside##*=>}"
          new_part="${new_part## }"
        fi

        canonical_path="${prefix}${new_part}${suffix}"
      else
        canonical_path="${raw_path##*=> }"
        if [[ "$canonical_path" == "$raw_path" ]]; then
          canonical_path="${raw_path##*=>}"
          canonical_path="${canonical_path## }"
        fi
      fi
    fi

    numstat_by_path["$canonical_path"]="${add}"$'\t'"${del}"
  done <<< "$numstat_lines"

  while IFS=$'\t' read -r kind src dest; do
    [[ -z "$src" ]] && continue

    typeset display_path="$src"
    typeset file_path="$src"
    if [[ ( "$kind" == R* || "$kind" == C* ) && -n "$dest" ]]; then
      display_path="${src} -> ${dest}"
      file_path="$dest"
    fi

    file_list+=("$file_path")

    typeset add="-"
    typeset del="-"
    typeset stats="${numstat_by_path["$file_path"]-}"
    if [[ -n "$stats" ]]; then
      add="${stats%%$'\t'*}"
      del="${stats#*$'\t'}"
      [[ "$add" != "-" ]] && total_add=$((total_add + add))
      [[ "$del" != "-" ]] && total_del=$((total_del + del))
    fi

    typeset color="$(_git_scope_kind_color "$kind")"
    printf "  %bâ¤ [%s] %s  [+%s / -%s]%b\n" "$color" "$kind" "$display_path" "$add" "$del" "$color_reset"
  done <<< "$ns_lines"

  printf "\n  ğŸ“Š Total: +%d / -%d\n" "$total_add" "$total_del"
  _git_scope_render_tree "${(F)file_list}"

  _git_scope_commit_file_list=("${file_list[@]}")
}

# git-scope: Working tree/commit introspection (dispatcher)
# Usage: git-scope <command> [args]
# - Subcommands: tracked, staged, unstaged, all, untracked, commit <id>
# - Flags: -p|--print prints file contents where applicable (e.g., commit)
# - Runs inside a Git repo; renders trees, diffs, and summaries
git-scope() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    printf "âš ï¸ Not a Git repository. Run this command inside a Git project.\n"
    return 1
  fi

  _git_scope_no_color=false
  if [[ -n "${NO_COLOR-}" ]]; then
    _git_scope_no_color=true
  fi

  typeset -a filtered_args=()
  for arg in "$@"; do
    if [[ "$arg" == "--no-color" || "$arg" == "no-color" ]]; then
      _git_scope_no_color=true
    else
      filtered_args+=("$arg")
    fi
  done

  typeset sub="${filtered_args[1]:-help}"
  (( ${#filtered_args[@]} > 0 )) && filtered_args=("${filtered_args[@]:1}")

  # Detect -p flag (print file content)
  _git_scope_should_print=false
  typeset -a args=()
  for arg in "${filtered_args[@]}"; do
    if [[ "$arg" == "-p" || "$arg" == "--print" ]]; then
      _git_scope_should_print=true
    else
      args+=("$arg")
    fi
  done

  case "$sub" in
    tracked)
      _git_scope_tracked "${args[@]}" ;;
    staged)
      _git_scope_staged "${args[@]}" ;;
    unstaged)
      _git_scope_unstaged "${args[@]}" ;;
    all)
      _git_scope_all "${args[@]}" ;;
    untracked)
      _git_scope_untracked "${args[@]}" ;;
    commit)
      _git_scope_commit "${args[@]}" ;;
    help|-h|--help|"")
      printf "%s\n" "Usage: git-scope <command> [args]"
      printf "\n"
      printf "%s\n" "Commands:"
      printf "  %-16s  %s\n" \
        tracked        "Show files tracked by Git (prefix filter optional)" \
        staged         "Show files staged for commit" \
        unstaged       "Show modified files not yet staged" \
        all            "Show all changes (staged and unstaged)" \
        untracked      "Show untracked files"
      printf "  %-16s  %s\n" "commit <id>" "Show commit details (use -p to print content)"
      printf "\n"
      printf "%s\n" "Options:"
      printf "  %-16s  %s\n" "-p, --print" "Print file contents where applicable (e.g., commit)"
      printf "  %-16s  %s\n" "--no-color" "Disable ANSI colors (also via NO_COLOR)"
      ;;
    *)
      printf "âš ï¸ Unknown subcommand: '%s'\n" "$sub"
      return 1 ;;
  esac
}

# --- END git/git-scope.zsh

if ! typeset -f git-scope >/dev/null 2>&1; then
  print -u2 -r -- "âŒ missing function: git-scope"
  exit 1
fi

git-scope "$@"
