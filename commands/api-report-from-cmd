#!/usr/bin/env bash
set -euo pipefail

# Bundled from: $HOME/.codex/commands/api-report-from-cmd
# --- BEGIN commands/api-report-from-cmd

if [[ -z "${CODEX_HOME:-}" ]]; then
  repo_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd -P)"
  export CODEX_HOME="$repo_root"
fi

die() {
  echo "api-report-from-cmd: $1" >&2
  exit 2
}

usage() {
  cat >&2 <<'EOF'
Usage:
  api-report-from-cmd [options] '<command snippet>'
  api-report-from-cmd [options] --stdin

Purpose:
  Rewrite a saved `gql.sh` / `rest.sh` command snippet into the corresponding
  report generator (`gql-report.sh` / `rest-report.sh`) and run it.

Options:
  --case <name>        Override the report case name (default: derived from op/request + env/jwt/token)
  --out <path>         Pass through to the report script as --out
  --response <file>    Use an existing response file (no network); passed to the report script as --response
                       Use "-" to read response from stdin.
  --allow-empty        GraphQL only: pass through to `gql-report.sh --allow-empty`
  --dry-run            Print the rewritten command and exit 0 (does not execute)
  --stdin              Read the command snippet from stdin (cannot combine with --response -)
  -h, --help           Show help

Examples:
  # Convert a gql-history snippet into a report (runs the API call)
  api-report-from-cmd '
  $CODEX_HOME/skills/tools/testing/graphql-api-testing/scripts/gql.sh \
    --config-dir /path/to/repo/setup/graphql \
    --env local \
    --jwt member \
    setup/graphql/operations/articles.graphql \
    setup/graphql/operations/articles.variables.json \
  | jq .
  '

  # Same, but generate from an existing response snapshot (no API call)
  api-report-from-cmd --response out/response.json '
  $CODEX_HOME/skills/tools/testing/graphql-api-testing/scripts/gql.sh \
    --config-dir /path/to/repo/setup/graphql \
    --env local \
    --jwt member \
    setup/graphql/operations/articles.graphql \
    setup/graphql/operations/articles.variables.json \
  | jq .
  '
EOF
}

expand_tilde() {
  local path="${1:-}"
  if [[ $path == \~ || $path == \~/* ]]; then
    path="${path/#\~/$HOME}"
  fi
  printf "%s" "$path"
}

case_override=""
out_arg=""
response_arg=""
allow_empty="0"
dry_run="0"
from_stdin="0"

while [[ $# -gt 0 ]]; do
  case "${1:-}" in
    --case)
      case_override="${2:-}"
      [[ -n "$case_override" ]] || die "missing value for --case"
      shift 2
      ;;
    --out)
      out_arg="${2:-}"
      [[ -n "$out_arg" ]] || die "missing value for --out"
      shift 2
      ;;
    --response)
      response_arg="${2:-}"
      [[ -n "$response_arg" ]] || die "missing value for --response"
      shift 2
      ;;
    --allow-empty)
      allow_empty="1"
      shift
      ;;
    --dry-run)
      dry_run="1"
      shift
      ;;
    --stdin)
      from_stdin="1"
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
  esac
done

if [[ "$from_stdin" == "1" && "$response_arg" == "-" ]]; then
  die "--stdin cannot be used with --response - (stdin needed for the response)."
fi

cmd_input=""
if [[ "$from_stdin" == "1" ]]; then
  cmd_input="$(cat)"
else
  [[ $# -gt 0 ]] || die "missing command snippet (pass a quoted string or use --stdin)"
  cmd_input="$*"
fi

python_bin="$(command -v python3 || true)"
if [[ -z "$python_bin" ]]; then
  python_bin="$(command -v python || true)"
fi
[[ -n "$python_bin" ]] || die "python3 (or python) is required for parsing"

mapfile -d '' -t tokens < <(
  printf '%s' "$cmd_input" \
  | "$python_bin" -c '
import os
import re
import shlex
import sys

raw = sys.stdin.read()
cmd = os.path.expandvars(raw)
cmd = re.sub(r"\\\r?\n\s*", " ", cmd)
cmd = cmd.replace("\r", " ").replace("\n", " ")
tokens = shlex.split(cmd, posix=True)
if "|" in tokens:
    tokens = tokens[: tokens.index("|")]
for t in tokens:
    sys.stdout.write(t + "\0")
'
)

[[ ${#tokens[@]} -gt 0 ]] || die "failed to parse command snippet (no tokens)"

script="${tokens[0]}"
script_base="$(basename "$script")"

kind=""
case "$script_base" in
  gql.sh) kind="graphql" ;;
  rest.sh) kind="rest" ;;
  *)
    die "unsupported script (expected gql.sh or rest.sh): $script"
    ;;
esac

config_dir=""
env_name=""
explicit_url=""
jwt_name=""
token_name=""
positional=()

i=1
while [[ $i -lt ${#tokens[@]} ]]; do
  t="${tokens[$i]}"
  case "$t" in
    --config-dir)
      config_dir="${tokens[$((i + 1))]:-}"
      [[ -n "$config_dir" ]] || die "missing value for --config-dir"
      i=$((i + 2))
      ;;
    -e|--env)
      env_name="${tokens[$((i + 1))]:-}"
      [[ -n "$env_name" ]] || die "missing value for --env"
      i=$((i + 2))
      ;;
    -u|--url)
      explicit_url="${tokens[$((i + 1))]:-}"
      [[ -n "$explicit_url" ]] || die "missing value for --url"
      i=$((i + 2))
      ;;
    --jwt)
      jwt_name="${tokens[$((i + 1))]:-}"
      [[ -n "$jwt_name" ]] || die "missing value for --jwt"
      i=$((i + 2))
      ;;
    --token)
      token_name="${tokens[$((i + 1))]:-}"
      [[ -n "$token_name" ]] || die "missing value for --token"
      i=$((i + 2))
      ;;
    --no-history|--list-envs|--list-jwts)
      i=$((i + 1))
      ;;
    *)
      positional+=("$t")
      i=$((i + 1))
      ;;
  esac
done

project_root=""
if [[ -n "$config_dir" ]]; then
  config_dir="$(expand_tilde "$config_dir")"
fi
if [[ -n "$out_arg" ]]; then
  out_arg="$(expand_tilde "$out_arg")"
fi
if [[ -n "$response_arg" ]]; then
  response_arg="$(expand_tilde "$response_arg")"
fi
if [[ -n "$config_dir" ]]; then
  project_root="$(git -C "$config_dir" rev-parse --show-toplevel 2>/dev/null || true)"
fi

if [[ -z "$project_root" && -n "$config_dir" ]]; then
  case "$config_dir" in
    */setup/graphql) project_root="${config_dir%/setup/graphql}" ;;
    */setup/rest) project_root="${config_dir%/setup/rest}" ;;
  esac
fi

resolve_in_project() {
  local path="$1"
  path="$(expand_tilde "$path")"
  if [[ -z "$path" ]]; then
    printf "%s" ""
    return 0
  fi
  if [[ "$path" == /* ]]; then
    printf "%s" "$path"
    return 0
  fi
  if [[ -n "$project_root" ]]; then
    printf "%s" "${project_root%/}/${path#./}"
    return 0
  fi
  printf "%s" "$path"
}

if [[ -n "$out_arg" ]]; then
  out_arg="$(resolve_in_project "$out_arg")"
fi
if [[ -n "$response_arg" && "$response_arg" != "-" ]]; then
  response_arg="$(resolve_in_project "$response_arg")"
fi

derive_case() {
  local base="$1"
  shift || true
  local meta=()
  local endpoint=''
  if [[ -n "$explicit_url" ]]; then
    endpoint="url"
  elif [[ -n "$env_name" ]]; then
    endpoint="$env_name"
  fi
  [[ -n "$endpoint" ]] && meta+=("$endpoint")
  if [[ "$kind" == "graphql" && -n "$jwt_name" ]]; then
    meta+=("$jwt_name")
  fi
  if [[ "$kind" == "rest" && -n "$token_name" ]]; then
    meta+=("token:$token_name")
  fi
  if [[ ${#meta[@]} -gt 0 ]]; then
    local joined=''
    local sep=''
    local item=''
    for item in "${meta[@]}"; do
      joined+="${sep}${item}"
      sep=", "
    done
    printf "%s (%s)" "$base" "$joined"
  else
    printf "%s" "$base"
  fi
}

report_cmd=()

if [[ "$kind" == "graphql" ]]; then
  op="${positional[0]:-}"
  vars="${positional[1]:-}"
  [[ -n "$op" ]] || die "missing positional operation file"

  report_script="$(dirname "$script")/gql-report.sh"
  [[ -x "$report_script" ]] || die "gql-report.sh not found or not executable: $report_script"

  op_abs="$(resolve_in_project "$op")"
  vars_abs="$(resolve_in_project "$vars")"

  case_name="$case_override"
  if [[ -z "$case_name" ]]; then
    base="$(basename "$op")"
    base="${base%.graphql}"
    case_name="$(derive_case "$base")"
  fi

  report_cmd+=("$report_script" --case "$case_name" --op "$op_abs")
  [[ -n "$vars" ]] && report_cmd+=(--vars "$vars_abs")
  [[ -n "$out_arg" ]] && report_cmd+=(--out "$out_arg")
  [[ -n "$project_root" ]] && report_cmd+=(--project-root "$project_root")
  [[ -n "$config_dir" ]] && report_cmd+=(--config-dir "$config_dir")
  [[ -n "$explicit_url" ]] && report_cmd+=(--url "$explicit_url")
  [[ -n "$env_name" && -z "$explicit_url" ]] && report_cmd+=(--env "$env_name")
  [[ -n "$jwt_name" ]] && report_cmd+=(--jwt "$jwt_name")
  [[ "$allow_empty" == "1" ]] && report_cmd+=(--allow-empty)
  if [[ -n "$response_arg" ]]; then
    report_cmd+=(--response "$response_arg")
  else
    report_cmd+=(--run)
  fi
elif [[ "$kind" == "rest" ]]; then
  req="${positional[0]:-}"
  [[ -n "$req" ]] || die "missing positional request file"

  report_script="$(dirname "$script")/rest-report.sh"
  [[ -x "$report_script" ]] || die "rest-report.sh not found or not executable: $report_script"

  req_abs="$(resolve_in_project "$req")"

  case_name="$case_override"
  if [[ -z "$case_name" ]]; then
    base="$(basename "$req")"
    base="${base%.request.json}"
    case_name="$(derive_case "$base")"
  fi

  report_cmd+=("$report_script" --case "$case_name" --request "$req_abs")
  [[ -n "$out_arg" ]] && report_cmd+=(--out "$out_arg")
  [[ -n "$project_root" ]] && report_cmd+=(--project-root "$project_root")
  [[ -n "$config_dir" ]] && report_cmd+=(--config-dir "$config_dir")
  [[ -n "$explicit_url" ]] && report_cmd+=(--url "$explicit_url")
  [[ -n "$env_name" && -z "$explicit_url" ]] && report_cmd+=(--env "$env_name")
  [[ -n "$token_name" ]] && report_cmd+=(--token "$token_name")
  if [[ -n "$response_arg" ]]; then
    report_cmd+=(--response "$response_arg")
  else
    report_cmd+=(--run)
  fi
fi

if [[ "$dry_run" == "1" ]]; then
  printf "%q " "${report_cmd[@]}"
  printf "\n"
  exit 0
fi

exec "${report_cmd[@]}"

# --- END commands/api-report-from-cmd
