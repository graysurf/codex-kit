#!/usr/bin/env -S zsh -f
set -e

# Bundled from: /var/folders/3d/s2d3jvyn0g758lsd_2t79h1w0000gn/T/tmp.8fnvct8R5N
: "${ZDOTDIR:=$HOME/.config/zsh}"
export ZDOTDIR
export ZSH_CONFIG_DIR="${ZSH_CONFIG_DIR:-$ZDOTDIR/config}"
export ZSH_BOOTSTRAP_SCRIPT_DIR="${ZSH_BOOTSTRAP_SCRIPT_DIR:-$ZDOTDIR/bootstrap}"
export ZSH_SCRIPT_DIR="${ZSH_SCRIPT_DIR:-$ZDOTDIR/scripts}"

# --- BEGIN _internal/wrappers.bundle-prelude.zsh
# Wrapper runtime prelude for bundled cached CLI wrappers.
#
# This file is intended to be *inlined* into generated wrapper binaries under:
#   $ZSH_CACHE_DIR/wrappers/bin/*
#
# It should remain safe to execute (no top-level `return`), and it should not
# depend on any other files at runtime.

# bundle-wrapper.zsh emits `set -e`; disable it to match the previous wrapper behavior.
set +e

typeset wrapper_bin="${0:A:h}"
[[ -d "$wrapper_bin" ]] && export PATH="$wrapper_bin:$PATH"

typeset wrapper_cache_dir="${wrapper_bin:h:h}"
export ZSH_CACHE_DIR="${ZSH_CACHE_DIR:-$wrapper_cache_dir}"
export ZSH_COMPDUMP="${ZSH_COMPDUMP:-$ZSH_CACHE_DIR/.zcompdump}"

[[ -d "$ZSH_CACHE_DIR" ]] || mkdir -p -- "$ZSH_CACHE_DIR"


# --- END _internal/wrappers.bundle-prelude.zsh

# --- BEGIN ~/.config/zsh/bootstrap/00-preload.zsh
# safe_unalias [-v] <name...>
# Safely remove one or more aliases without causing errors.
#
# This utility function checks whether each given name is an existing alias,
# and only unaliases it if it exists. This avoids "no such hash table element"
# errors when running scripts that are sourced multiple times or across environments.
#
# It also supports an optional `-v` flag to enable verbose output for debugging.
#
# Usage:
#   safe_unalias foo bar       # Silently unalias 'foo' and 'bar' if they exist
#   safe_unalias -v foo bar    # Verbosely unalias 'foo' and 'bar'
#
# Notes:
# - This function is meant to be defined early in the shell environment,
#   so it can be reused safely in all scripts.
# - It only affects aliases (not functions or commands).
safe_unalias() {
  typeset verbose=false
  typeset first_arg="${1-}"

  if [[ "$first_arg" == "-v" ]]; then
    verbose=true
    shift
  fi

  for name in "$@"; do
    if alias "$name" &>/dev/null; then
      $verbose && printf "üîÅ Unaliasing %s\n" "$name"
      unalias "$name"
    fi
  done

  return 0
}

# get_clipboard
# Read clipboard contents and print to stdout.
# Usage: get_clipboard
# Notes:
# - Requires pbpaste (macOS) or xclip/xsel (Linux).
get_clipboard() {
  if command -v pbpaste >/dev/null 2>&1; then
    pbpaste
  elif command -v xclip >/dev/null 2>&1; then
    xclip -selection clipboard -o
  elif command -v xsel >/dev/null 2>&1; then
    xsel --clipboard --output
  else
    printf "‚ùå No clipboard tool found (requires pbpaste, xclip, or xsel)\n" >&2
    return 1
  fi
}

# set_clipboard
# Read stdin and write it to the system clipboard.
# Usage: <command> | set_clipboard
# Notes:
# - Requires pbcopy (macOS) or xclip/xsel (Linux).
set_clipboard() {
  if command -v pbcopy >/dev/null 2>&1; then
    pbcopy
  elif command -v xclip >/dev/null 2>&1; then
    xclip -selection clipboard -i
  elif command -v xsel >/dev/null 2>&1; then
    xsel --clipboard --input
  else
    printf "‚ùå No clipboard tool found (requires pbcopy, xclip, or xsel)\n" >&2
    return 1
  fi
}

# --- END ~/.config/zsh/bootstrap/00-preload.zsh

# --- BEGIN git/tools/git-utils.zsh
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Git utility helpers
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if command -v safe_unalias >/dev/null; then
  safe_unalias \
    git-zip \
    git-copy-staged \
    git-root \
    get_commit_hash
fi

# git-zip
# Export `HEAD` as a zip file named by short hash.
# Usage: git-zip
# Notes:
# - Writes `backup-<sha>.zip` in the current directory.
git-zip() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  git archive --format zip HEAD -o "backup-$(git rev-parse --short HEAD).zip"
  return $?
}

# git-copy-staged [--stdout|--both]
# Copy staged diff to clipboard (default) or print to stdout.
# Usage: git-copy-staged [--stdout|--both]
# Notes:
# - Requires `set_clipboard` for clipboard mode.
# - Returns non-zero when there are no staged changes.
git-copy-staged() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  typeset diff='' mode='clipboard' arg=''
  typeset -i mode_flags=0
  typeset -a extra_args=()

  while [[ $# -gt 0 ]]; do
    arg="${1-}"
    case "$arg" in
      --stdout|-p|--print)
        mode="stdout"
        (( mode_flags++ ))
        ;;
      --both)
        mode="both"
        (( mode_flags++ ))
        ;;
      --help|-h)
        print -r -- "Usage: git-copy-staged [--stdout|--both]"
        print -r -- "  --stdout   Print staged diff to stdout (no status message)"
        print -r -- "  --both     Print to stdout and copy to clipboard"
        return 0
        ;;
      *)
        extra_args+=("$arg")
        ;;
    esac
    shift
  done

  if (( mode_flags > 1 )); then
    print -u2 -r -- "‚ùó Only one output mode is allowed: --stdout or --both"
    return 1
  fi

  if (( ${#extra_args[@]} > 0 )); then
    print -u2 -r -- "‚ùó Unknown argument: ${extra_args[1]}"
    print -u2 -r -- "Usage: git-copy-staged [--stdout|--both]"
    return 1
  fi

  diff=$(git diff --cached --no-color)

  if [[ -z "$diff" ]]; then
    print -r -- "‚ö†Ô∏è  No staged changes to copy"
    return 1
  fi

  if [[ "$mode" == "stdout" ]]; then
    printf "%s\n" "$diff"
    return 0
  fi

  printf "%s" "$diff" | set_clipboard

  if [[ "$mode" == "both" ]]; then
    printf "%s\n" "$diff"
  fi

  print -r -- "‚úÖ Staged diff copied to clipboard"
  return 0
}

# git-root
# `cd` to the root directory of the current Git repository.
# Usage: git-root
# Notes:
# - Prints the resolved root path after changing directory.
git-root() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  typeset root=''
  root=$(git rev-parse --show-toplevel 2>/dev/null) || {
    print -u2 -r -- "‚ùå Not in a git repository"
    return 1
  }

  if ! cd "$root"; then
    print -u2 -r -- "‚ùå Failed to cd to git root: $root"
    return 1
  fi

  print -r -- ""
  print -r -- "üìÅ Jumped to Git root: $root"
  return 0
}

# get_commit_hash <ref>
# Print the commit SHA for a ref (supports annotated tags via `^{commit}`).
# Usage: get_commit_hash <ref>
# Output:
# - Prints the commit SHA to stdout.
get_commit_hash() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  typeset ref="${1-}"
  if [[ -z "$ref" ]]; then
    print -u2 -r -- "‚ùå Missing git ref"
    return 1
  fi

  # Try resolve commit (handles annotated tags too)
  git rev-parse --verify --quiet "${ref}^{commit}"
  return $?
}

# --- END git/tools/git-utils.zsh

# --- BEGIN git/tools/git-reset.zsh
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Git reset helpers
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if command -v safe_unalias >/dev/null; then
  safe_unalias \
    git-reset-soft \
    git-reset-hard \
    git-reset-mixed \
    git-reset-undo \
    git-back-head \
    git-back-checkout \
    git-reset-remote
fi

# _git_reset_confirm <prompt>
# Prompt for y/N confirmation (returns 0 only on "y"/"Y").
# Usage: _git_reset_confirm <prompt>
_git_reset_confirm() {
  emulate -L zsh

  typeset prompt="${1-}"
  [[ -n "$prompt" ]] || return 1
  shift || true

  print -n -r -- "$prompt"

  typeset confirm=''
  IFS= read -r confirm
  [[ "$confirm" == [yY] ]]
}

# _git_reset_confirm_or_abort <prompt>
# Prompt for confirmation; print "Aborted" and return non-zero on decline.
# Usage: _git_reset_confirm_or_abort <prompt>
_git_reset_confirm_or_abort() {
  _git_reset_confirm "$@" && return 0
  print -r -- "üö´ Aborted"
  return 1
}

# _git_reset_by_count <mode> [N]
# Reset `HEAD` back by N commits using the given mode (interactive confirmation).
# Usage: _git_reset_by_count <soft|mixed|hard> [N]
_git_reset_by_count() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  typeset mode='' count_arg='' extra_arg='' prompt='' failure='' success='' line=''
  typeset commit_label='' target=''
  typeset -i count=1
  typeset -a preface=()

  mode="${1-}"
  count_arg="${2-}"
  extra_arg="${3-}"

  if [[ -z "$mode" ]]; then
    print -u2 -r -- "‚ùå Missing reset mode."
    return 2
  fi

  if [[ -n "$extra_arg" ]]; then
    print -u2 -r -- "‚ùå Too many arguments."
    print -u2 -r -- "Usage: git-reset-$mode [N]"
    return 2
  fi

  if [[ -n "$count_arg" ]]; then
    if [[ "$count_arg" != <-> || "$count_arg" -le 0 ]]; then
      print -u2 -r -- "‚ùå Invalid commit count: $count_arg (must be a positive integer)."
      print -u2 -r -- "Usage: git-reset-$mode [N]"
      return 2
    fi
    count="$count_arg"
  fi

  target="HEAD~$count"
  if ! git rev-parse --verify --quiet "$target" >/dev/null; then
    print -u2 -r -- "‚ùå Cannot resolve $target (not enough commits?)."
    return 1
  fi

  commit_label='last commit'
  if (( count > 1 )); then
    commit_label="last $count commits"
  fi

  case "$mode" in
    soft)
      preface=(
        "‚ö†Ô∏è  This will rewind your $commit_label (soft reset)"
        "üß† Your changes will remain STAGED. Useful for rewriting commit message."
      )
      prompt="‚ùì Proceed with 'git reset --soft $target'? [y/N] "
      failure="‚ùå Soft reset failed."
      success="‚úÖ Reset completed. Your changes are still staged."
      ;;
    hard)
      preface=(
        "‚ö†Ô∏è  This will HARD RESET your repository to $target."
        "üî• Tracked staged/unstaged changes will be OVERWRITTEN."
        "üß® This is equivalent to: git reset --hard $target"
      )
      prompt="‚ùì Are you absolutely sure? [y/N] "
      failure="‚ùå Hard reset failed."
      success="‚úÖ Hard reset completed. HEAD moved back to $target."
      ;;
    mixed)
      preface=(
        "‚ö†Ô∏è  This will rewind your $commit_label (mixed reset)"
        "üß† Your changes will become UNSTAGED and editable in working directory."
      )
      prompt="‚ùì Proceed with 'git reset --mixed $target'? [y/N] "
      failure="‚ùå Mixed reset failed."
      success="‚úÖ Reset completed. Your changes are now unstaged."
      ;;
    *)
      print -u2 -r -- "‚ùå Unknown reset mode: ${mode:-}"
      return 2
      ;;
  esac

  for line in "${preface[@]}"; do
    print -r -- "$line"
  done
  print -r -- "üßæ Commits to be rewound:"
  git log --no-color -n "$count" --date=format:'%m-%d %H:%M' --pretty='%h %ad %an  %s' || return 1
  _git_reset_confirm_or_abort "$prompt" || return 1

  if ! git reset "--$mode" "$target"; then
    print -r -- "$failure"
    return 1
  fi

  print -r -- "$success"
  return 0
}

# git-reset-soft [N]
# Undo the last commit(s) while keeping changes staged (soft reset).
# Usage: git-reset-soft [N]
# Notes:
# - Runs `git reset --soft HEAD~N` after showing the commits to be rewound.
git-reset-soft() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  _git_reset_by_count soft "$@"
  return $?
}

# git-reset-hard [N]
# Hard reset to the previous commit(s) with confirmation (DANGEROUS).
# Usage: git-reset-hard [N]
# Safety:
# - Discards tracked staged/unstaged changes; untracked files are NOT removed.
git-reset-hard() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  # Note: Untracked files may still exist; `git status` may not be clean.
  _git_reset_by_count hard "$@"
  return $?
}

# git-reset-mixed [N]
# Undo the last commit(s) and unstage changes (mixed reset).
# Usage: git-reset-mixed [N]
# Notes:
# - Runs `git reset --mixed HEAD~N` after showing the commits to be rewound.
git-reset-mixed() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  _git_reset_by_count mixed "$@"
  return $?
}

# git-reset-undo
# Undo the last HEAD move using reflog (interactive; offers soft/mixed/hard choices).
# Usage: git-reset-undo
# Notes:
# - Target: HEAD@{1} (previous HEAD position).
# - Detects in-progress operations (merge/rebase/etc.) and asks for extra confirmation.
# Safety:
# - Can rewrite history and/or discard tracked changes depending on your choice.
git-reset-undo() {
  typeset target_commit
  typeset status_lines
  typeset reflog_line_current reflog_subject_current
  typeset reflog_line_target  reflog_subject_target
  typeset choice
  typeset -a op_warnings

  # ‚îÄ‚îÄ Safety: ensure we are inside a Git repository ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    print "‚ùå Not a git repository."
    return 1
  fi

  # Resolve the TARGET commit (previous HEAD position) to a stable SHA.
  # We intentionally capture the SHA early so the action later is deterministic.
  target_commit=$(git rev-parse HEAD@{1} 2>/dev/null)
  if [[ -z "$target_commit" ]]; then
    print "‚ùå Cannot resolve HEAD@{1} (no previous HEAD position in reflog)."
    return 1
  fi

  # ‚îÄ‚îÄ Optional safety: detect in-progress operations (merge/rebase/etc.) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  op_warnings=()

  # merge in progress
  [[ -f "$(git rev-parse --git-path MERGE_HEAD 2>/dev/null)" ]] \
    && op_warnings+=("merge in progress (suggest: git merge --abort)")

  # rebase in progress (either layout)
  [[ -d "$(git rev-parse --git-path rebase-apply 2>/dev/null)" || -d "$(git rev-parse --git-path rebase-merge 2>/dev/null)" ]] \
    && op_warnings+=("rebase in progress (suggest: git rebase --abort)")

  # cherry-pick in progress
  [[ -f "$(git rev-parse --git-path CHERRY_PICK_HEAD 2>/dev/null)" ]] \
    && op_warnings+=("cherry-pick in progress (suggest: git cherry-pick --abort)")

  # revert in progress
  [[ -f "$(git rev-parse --git-path REVERT_HEAD 2>/dev/null)" ]] \
    && op_warnings+=("revert in progress (suggest: git revert --abort)")

  # bisect in progress (heuristic)
  [[ -f "$(git rev-parse --git-path BISECT_LOG 2>/dev/null)" ]] \
    && op_warnings+=("bisect in progress (suggest: git bisect reset)")

  if (( ${#op_warnings[@]} > 0 )); then
    print "üõ°Ô∏è  Detected an in-progress Git operation:"
    for w in "${op_warnings[@]}"; do
      print "   - $w"
    done
    print "‚ö†Ô∏è  Resetting during these operations can be confusing."
    _git_reset_confirm_or_abort "‚ùì Still run git-reset-undo (move HEAD back)? [y/N] " || return 1
  fi

  # ‚îÄ‚îÄ Reflog display (with fallback for portability) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Preferred: direct HEAD@{n} form (most Git environments support this).
  reflog_line_current=$(git reflog -1 --pretty='%h %gs' HEAD@{0} 2>/dev/null)
  reflog_subject_current=$(git reflog -1 --pretty='%gs' HEAD@{0} 2>/dev/null)

  if [[ -z "$reflog_line_current" || -z "$reflog_subject_current" ]]; then
    # Fallback: reflog show latest entry for HEAD (informational only)
    reflog_line_current=$(git reflog show -1 --pretty='%h %gs' HEAD 2>/dev/null)
    reflog_subject_current=$(git reflog show -1 --pretty='%gs' HEAD 2>/dev/null)
  fi

  reflog_line_target=$(git reflog -1 --pretty='%h %gs' HEAD@{1} 2>/dev/null)
  reflog_subject_target=$(git reflog -1 --pretty='%gs' HEAD@{1} 2>/dev/null)

  if [[ -z "$reflog_line_target" || -z "$reflog_subject_target" ]]; then
    # Fallback: take the 2nd entry from reflog show -2 (informational only)
    reflog_line_target=$(git reflog show -2 --pretty='%h %gs' HEAD 2>/dev/null | sed -n '2p')
    reflog_subject_target=$(git reflog show -2 --pretty='%gs' HEAD 2>/dev/null | sed -n '2p')
  fi

  # If reflog lines are still unavailable, keep going (reflog display is informational).
  [[ -z "$reflog_line_current" ]] && reflog_line_current="(unavailable)"
  [[ -z "$reflog_line_target"  ]] && reflog_line_target="(unavailable)"
  [[ -z "$reflog_subject_current" ]] && reflog_subject_current="(unavailable)"
  [[ -z "$reflog_subject_target"  ]] && reflog_subject_target="(unavailable)"

  print "üßæ Current HEAD@{0} (last action):"
  print "   $reflog_line_current"
  print "üßæ Target  HEAD@{1} (previous HEAD position):"
  print "   $reflog_line_target"

  # If reflog display failed, clarify that the action is still deterministic via target_commit
  if [[ "$reflog_line_current" == "(unavailable)" || "$reflog_line_target" == "(unavailable)" ]]; then
    print "‚ÑπÔ∏è  Reflog display unavailable here; reset target is still the resolved SHA: $target_commit"
  fi

  # Extra confirmation if the LAST action (HEAD@{0}) wasn't a reset.
  # (We still allow it‚Äîthis tool can undo any HEAD move‚Äîbut we make it explicit.)
  if [[ "$reflog_subject_current" != reset:* && "$reflog_subject_current" != "(unavailable)" ]]; then
    print "‚ö†Ô∏è  The last action does NOT look like a reset operation."
    print "üß† It may be from checkout/rebase/merge/pull, etc."
    _git_reset_confirm_or_abort "‚ùì Still proceed to move HEAD back to the previous HEAD position? [y/N] " || return 1
  fi

  # Show the exact commit we are about to restore to (the stable SHA we resolved)
  print "üï∞  Target commit (resolved from HEAD@{1}):"
  git log --oneline -1 "$target_commit" || return 1

  # Detect ANY local changes including untracked (default porcelain includes untracked)
  status_lines=$(git status --porcelain 2>/dev/null) || return 1

  # If there are no changes, safely hard reset without extra prompts
  if [[ -z "$status_lines" ]]; then
    print "‚úÖ Working tree clean. Proceeding with: git reset --hard $target_commit"
    if ! git reset --hard "$target_commit"; then
      print "‚ùå Hard reset failed."
      return 1
    fi
    print "‚úÖ Repository reset back to previous HEAD: $target_commit"
    return 0
  fi

  # If there are changes, warn and offer choices
  print "‚ö†Ô∏è  Working tree has changes:"
  print -r -- "$status_lines"
  print ""
  print "Choose how to proceed:"
  print "  1) Keep changes + PRESERVE INDEX (staged vs new base)  (git reset --soft  $target_commit)"
  print "  2) Keep changes + UNSTAGE ALL                          (git reset --mixed $target_commit)"
  print "  3) Discard tracked changes                             (git reset --hard  $target_commit)"
  print "  4) Abort"
  print -n "‚ùì Select [1/2/3/4] (default: 4): "
  read -r choice

  case "$choice" in
    1)
      print "üß∑ Preserving INDEX (staged) and working tree. Running: git reset --soft $target_commit"
      print "‚ö†Ô∏è  Note: The index is preserved, but what appears staged is relative to the new HEAD."
      if ! git reset --soft "$target_commit"; then
        print "‚ùå Soft reset failed."
        return 1
      fi
      print "‚úÖ HEAD moved back while preserving index + working tree: $target_commit"
      ;;

    2)
      print "üß∑ Preserving working tree but clearing INDEX (unstage all). Running: git reset --mixed $target_commit"
      if ! git reset --mixed "$target_commit"; then
        print "‚ùå Mixed reset failed."
        return 1
      fi
      print "‚úÖ HEAD moved back; working tree preserved; index reset: $target_commit"
      ;;

    3)
      print "üî• Discarding tracked changes. Running: git reset --hard $target_commit"
      print "‚ö†Ô∏è  This overwrites tracked files in working tree + index."
      print "‚ÑπÔ∏è  Untracked files are NOT removed by reset --hard."
      _git_reset_confirm_or_abort "‚ùì Are you absolutely sure? [y/N] " || return 1
      if ! git reset --hard "$target_commit"; then
        print "‚ùå Hard reset failed."
        return 1
      fi
      print "‚úÖ Repository reset back to previous HEAD: $target_commit"
      ;;

    *)
      print "üö´ Aborted"
      return 1
      ;;
  esac

  return 0
}

# git-back-head
# Move HEAD back to its previous position using reflog (via `git checkout HEAD@{1}`).
# Usage: git-back-head
# Notes:
# - May update tracked files to match the target state; checkout can fail if it would overwrite changes.
# - Depending on reflog, you may end up in detached HEAD.
git-back-head() {
  typeset prev_head

  # Resolve HEAD@{1} to a commit SHA for display/validation
  prev_head=$(git rev-parse HEAD@{1} 2>/dev/null)
  if [[ -z "$prev_head" ]]; then
    print "‚ùå Cannot find previous HEAD in reflog."
    return 1
  fi

  print "‚è™ This will move HEAD back to the previous position (HEAD@{1}):"
  print "üîÅ $(git log --oneline -1 "$prev_head")"
  _git_reset_confirm_or_abort "‚ùì Proceed with 'git checkout HEAD@{1}'? [y/N] " || return 1

  # Move HEAD back using reflog syntax (requested)
  git checkout HEAD@{1}
  if [[ $? -ne 0 ]]; then
    print "‚ùå Checkout failed (likely due to local changes or invalid reflog state)."
    return 1
  fi

  print "‚úÖ Restored to previous HEAD (HEAD@{1}): $prev_head"
}

# git-back-checkout
# Return to the previous branch from reflog (avoids detached HEAD when possible).
# Usage: git-back-checkout
# Notes:
# - Aborts in detached HEAD.
# - Verifies the previous branch exists locally before checkout.
# Safety:
# - Checkout may fail if local changes would be overwritten.
git-back-checkout() {
  typeset current_branch from_branch

  # Determine the current branch; in detached HEAD this becomes literal "HEAD"
  current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) || return 1
  if [[ -z "$current_branch" ]]; then
    print "‚ùå Cannot determine current branch."
    return 1
  fi

  # If we're detached, we can't reliably infer "previous branch" relative to a branch name
  if [[ "$current_branch" == "HEAD" ]]; then
    print "‚ùå You are in a detached HEAD state. This function targets branch-to-branch checkouts."
    print "üß† Tip: Use `git reflog` to find the branch/commit you want, then `git checkout <branch>`."
    return 1
  fi

  # Find the most recent reflog checkout entry that moved *to* current_branch,
  # then extract the "from" token.
  from_branch=$(
    git reflog |
      grep "checkout: moving from " |
      grep " to $current_branch" |
      sed -n 's/.*checkout: moving from \([^ ]*\) to '"$current_branch"'.*/\1/p' |
      head -n 1
  )

  if [[ -z "$from_branch" ]]; then
    print "‚ùå Could not find a previous checkout that switched to $current_branch."
    return 1
  fi

  # Skip if the extracted token looks like a commit SHA (7-40 hex chars).
  # This avoids accidentally checking out a commit and entering detached HEAD.
  if [[ "$from_branch" == <-> ]]; then
    # purely numeric branch names are rare but possible; don't treat as SHA
    :
  elif [[ "$from_branch" == (#i)[0-9a-f]## && ${#from_branch} -ge 7 && ${#from_branch} -le 40 ]]; then
    print "‚ùå Previous 'from' looks like a commit SHA ($from_branch). Refusing to checkout to avoid detached HEAD."
    print "üß† Use `git reflog` to choose the correct branch explicitly."
    return 1
  fi

  # Verify the branch exists locally before checking out
  if ! git show-ref --verify --quiet "refs/heads/$from_branch"; then
    print "‚ùå '$from_branch' is not an existing local branch."
    print "üß† If it's a remote branch, try: git checkout -t origin/$from_branch"
    return 1
  fi

  print "‚è™ This will move HEAD back to previous branch: $from_branch"
  _git_reset_confirm_or_abort "‚ùì Proceed with 'git checkout $from_branch'? [y/N] " || return 1

  git checkout "$from_branch"
  if [[ $? -ne 0 ]]; then
    print "‚ùå Checkout failed (likely due to local changes or conflicts)."
    return 1
  fi

  print "‚úÖ Restored to previous branch: $from_branch"
}

# git-reset-remote [options]
# Overwrite the current local branch with a remote-tracking branch (DANGEROUS).
# Usage: git-reset-remote [--ref <remote/branch>] [-r|--remote <name>] [-b|--branch <name>] [--no-fetch] [--prune] [--clean] [--set-upstream] [-y|--yes]
# Safety:
# - Discards tracked changes via `git reset --hard` and can optionally remove untracked files via `git clean -fd`.
git-reset-remote() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  zmodload zsh/zutil 2>/dev/null || {
    print -u2 -r -- "‚ùå zsh/zutil is required for zparseopts."
    return 1
  }

  typeset -A opts=()
  zparseopts -D -E -A opts -- \
    h -help \
    y -yes \
    r: -remote: \
    b: -branch: \
    -ref: \
    -no-fetch \
    -prune \
    -clean \
    -set-upstream || return 2

  if (( ${+opts[-h]} || ${+opts[--help]} )); then
    print -r -- "git-reset-remote: overwrite current local branch with a remote-tracking branch (DANGEROUS)"
    print -r --
    print -r -- "Usage:"
    print -r -- "  git-reset-remote  # reset current branch to its upstream (or origin/<branch>)"
    print -r -- "  git-reset-remote --ref origin/main"
    print -r -- "  git-reset-remote -r origin -b main"
    print -r --
    print -r -- "Options:"
    print -r -- "  -r, --remote <name>        Remote name (default: from upstream, else origin)"
    print -r -- "  -b, --branch <name>        Remote branch name (default: from upstream, else current branch)"
    print -r -- "      --ref <remote/branch>  Shortcut for --remote/--branch"
    print -r -- "      --no-fetch             Skip 'git fetch' (uses existing remote-tracking refs)"
    print -r -- "      --prune                Use 'git fetch --prune'"
    print -r -- "      --set-upstream         Set upstream of current branch to <remote>/<branch>"
    print -r -- "      --clean                After reset, optionally run 'git clean -fd' (removes untracked)"
    print -r -- "  -y, --yes                  Skip confirmations"
    return 0
  fi

  git rev-parse --git-dir >/dev/null 2>&1 || {
    print -u2 -r -- "‚ùå Not inside a Git repository."
    return 1
  }

  typeset current_branch=''
  current_branch="$(git symbolic-ref --quiet --short HEAD 2>/dev/null)" || {
    print -u2 -r -- "‚ùå Detached HEAD. Switch to a branch first."
    return 1
  }

  typeset upstream='' remote='' remote_branch='' ref=''
  upstream="$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null || true)"

  if [[ -n "${opts[--ref]-}" ]]; then
    ref="${opts[--ref]}"
    if [[ "$ref" != */* ]]; then
      print -u2 -r -- "‚ùå --ref must look like '<remote>/<branch>' (got: $ref)"
      return 2
    fi
    remote="${ref%%/*}"
    remote_branch="${ref#*/}"
  else
    remote="${opts[-r]-}"
    [[ -n "${opts[--remote]-}" ]] && remote="${opts[--remote]}"

    remote_branch="${opts[-b]-}"
    [[ -n "${opts[--branch]-}" ]] && remote_branch="${opts[--branch]}"

    if [[ -z "$remote" && -n "$upstream" && "$upstream" == */* ]]; then
      remote="${upstream%%/*}"
    fi
    [[ -z "$remote" ]] && remote='origin'

    if [[ -z "$remote_branch" ]]; then
      if [[ -n "$upstream" && "$upstream" == */* && "${upstream#*/}" != 'HEAD' ]]; then
        remote_branch="${upstream#*/}"
      else
        remote_branch="$current_branch"
      fi
    fi
  fi

  typeset target_ref="$remote/$remote_branch"
  typeset want_yes=0 want_clean=0 want_prune=0 want_fetch=1 want_set_upstream=0
  (( ${+opts[-y]} || ${+opts[--yes]} )) && want_yes=1
  (( ${+opts[--clean]} )) && want_clean=1
  (( ${+opts[--prune]} )) && want_prune=1
  (( ${+opts[--no-fetch]} )) && want_fetch=0
  (( ${+opts[--set-upstream]} )) && want_set_upstream=1

  if (( want_fetch )); then
    if (( want_prune )); then
      git fetch --prune -- "$remote" || return $?
    else
      git fetch -- "$remote" || return $?
    fi
  fi

  if ! git show-ref --verify --quiet "refs/remotes/$remote/$remote_branch"; then
    print -u2 -r -- "‚ùå Remote-tracking branch not found: $target_ref"
    print -u2 -r -- "   Try: git fetch --prune -- $remote"
    print -u2 -r -- "   Or verify: git branch -r | rg -n -- \"^\\s*$remote/$remote_branch$\""
    return 1
  fi

  typeset status_porcelain=''
  status_porcelain="$(git status --porcelain 2>/dev/null || true)"

  if (( !want_yes )); then
    print -r -- "‚ö†Ô∏è  This will OVERWRITE local branch '$current_branch' with '$target_ref'."
    if [[ -n "$status_porcelain" ]]; then
      print -r -- "üî• Tracked staged/unstaged changes will be DISCARDED by --hard."
      print -r -- "üßπ Untracked files will be kept (use --clean to remove)."
    fi
    _git_reset_confirm_or_abort "‚ùì Proceed with: git reset --hard $target_ref ? [y/N] " || return 1
  fi

  git reset --hard "$target_ref" || return $?

  if (( want_clean )); then
    if (( !want_yes )); then
      print -r -- "‚ö†Ô∏è  Next: git clean -fd (removes untracked files/dirs)"
      if ! _git_reset_confirm "‚ùì Proceed with: git clean -fd ? [y/N] "; then
        print -r -- "‚ÑπÔ∏è  Skipped git clean -fd"
        want_clean=0
      fi
    fi
    if (( want_clean )); then
      git clean -fd || return $?
    fi
  fi

  if (( want_set_upstream || ${#upstream} == 0 )); then
    git branch --set-upstream-to="$target_ref" "$current_branch" >/dev/null 2>&1 || true
  fi

  print -r -- "‚úÖ Done. '$current_branch' now matches '$target_ref'."
  return 0
}

# --- END git/tools/git-reset.zsh

# --- BEGIN git/tools/git-branch-cleanup.zsh
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Git branch cleanup helpers
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if command -v safe_unalias >/dev/null; then
  safe_unalias git-delete-merged-branches
fi

# git-delete-merged-branches [-b|--base <ref>] [-s|--squash]
# Delete merged local branches with confirmation.
# Usage: git-delete-merged-branches [-b|--base <ref>] [-s|--squash]
# Notes:
# - Protects current branch, base ref, and main/master/develop/trunk.
# - With `--squash`, treats branches as deletable when their commits are already applied (git cherry).
# Safety:
# - Deleting local branches is irreversible unless you still have the commit SHA (reflog may help).
git-delete-merged-branches() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  typeset base_ref='HEAD'
  typeset base_local=''
  typeset confirm=''
  typeset current_branch=''
  typeset branch=''
  typeset name=''
  typeset base_commit=''
  typeset head_commit=''
  typeset delete_flag='-d'
  typeset squash_mode=false
  typeset cherry_output=''
  typeset branch_delete_flag=''
  typeset -a protected_branches=(main master develop trunk)
  typeset -a merged_branches=()
  typeset -a local_branches=()
  typeset -a candidates=()
  typeset -A protected_set=()
  typeset -A merged_set=()
  typeset -A opts=()

  if ! zmodload zsh/zutil 2>/dev/null; then
    print -u2 -r -- "‚ùå zsh/zutil module is required for option parsing"
    return 1
  fi
  zparseopts -D -E -A opts -- h -help b: -base: s -squash

  if (( ${+opts[-h]} || ${+opts[--help]} )); then
    print -r -- "Usage: git-delete-merged-branches [-b|--base <ref>] [-s|--squash]"
    print -r -- "  -b, --base <ref>  Base ref used to determine merged branches (default: HEAD)"
    print -r -- "  -s, --squash      Include branches already applied to base (git cherry)"
    return 0
  fi

  if (( ${+opts[-s]} || ${+opts[--squash]} )); then
    squash_mode=true
  fi

  if (( ${+opts[-b]} )); then
    base_ref="${opts[-b]}"
  elif (( ${+opts[--base]} )); then
    base_ref="${opts[--base]}"
  fi

  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
    print -u2 -r -- "‚ùå Not in a git repository"
    return 1
  }

  git rev-parse --verify --quiet "$base_ref" >/dev/null || {
    print -u2 -r -- "‚ùå Invalid base ref: $base_ref"
    return 1
  }

  base_commit=$(git rev-parse "${base_ref}^{commit}" 2>/dev/null) || {
    print -u2 -r -- "‚ùå Unable to resolve base commit: $base_ref"
    return 1
  }
  head_commit=$(git rev-parse HEAD 2>/dev/null) || {
    print -u2 -r -- "‚ùå Unable to resolve HEAD commit"
    return 1
  }
  if [[ "$base_commit" != "$head_commit" ]]; then
    delete_flag='-D'
  fi

  current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) || {
    print -u2 -r -- "‚ùå Unable to resolve current branch"
    return 1
  }

  for name in "${protected_branches[@]}"; do
    protected_set[$name]=1
  done
  if [[ -n "$current_branch" && "$current_branch" != 'HEAD' ]]; then
    protected_set[$current_branch]=1
  fi
  protected_set[$base_ref]=1
  if git show-ref --verify --quiet "refs/remotes/$base_ref"; then
    base_local="${base_ref#*/}"
  elif git show-ref --verify --quiet "refs/heads/$base_ref"; then
    base_local="$base_ref"
  fi
  if [[ -n "$base_local" ]]; then
    protected_set[$base_local]=1
  fi

  merged_branches=(${(@f)$(git for-each-ref --merged "$base_ref" --format='%(refname:short)' refs/heads)})
  for branch in "${merged_branches[@]}"; do
    merged_set[$branch]=1
  done

  if [[ "$squash_mode" != true ]]; then
    if (( ${#merged_branches[@]} == 0 )); then
      print -r -- "‚úÖ No merged local branches found."
      return 0
    fi
  fi

  if [[ "$squash_mode" == true ]]; then
    local_branches=(${(@f)$(git for-each-ref --format='%(refname:short)' refs/heads)})
    if (( ${#local_branches[@]} == 0 )); then
      print -r -- "‚úÖ No local branches found."
      return 0
    fi

    for branch in "${local_branches[@]}"; do
      if (( ${+protected_set[$branch]} )); then
        continue
      fi

      if (( ${+merged_set[$branch]} )); then
        candidates+=("$branch")
        continue
      fi

      cherry_output=$(git cherry -v "$base_ref" "$branch" 2>/dev/null) || {
        print -u2 -r -- "‚ùå Failed to compare $branch against $base_ref"
        return 1
      }

      if [[ -n "$cherry_output" ]] && printf '%s\n' "$cherry_output" | command grep -q '^\+'; then
        continue
      fi

      candidates+=("$branch")
    done
  else
    for branch in "${merged_branches[@]}"; do
      if (( ${+protected_set[$branch]} )); then
        continue
      fi
      candidates+=("$branch")
    done
  fi

  if (( ${#candidates[@]} == 0 )); then
    if [[ "$squash_mode" == true ]]; then
      print -r -- "‚úÖ No deletable branches found."
    else
      print -r -- "‚úÖ No deletable merged branches."
    fi
    return 0
  fi

  if [[ "$squash_mode" == true ]]; then
    print -r -- "üßπ Branches to delete (base: $base_ref, mode: squash):"
  else
    print -r -- "üßπ Merged branches to delete (base: $base_ref):"
  fi
  printf '  - %s\n' "${candidates[@]}"
  print -n -r -- "‚ùì Proceed with deleting these branches? [y/N] "
  read -r confirm
  if [[ "$confirm" != [yY] ]]; then
    print -r -- "üö´ Aborted"
    return 1
  fi

  for branch in "${candidates[@]}"; do
    branch_delete_flag="$delete_flag"
    if [[ "$delete_flag" == '-d' && "$squash_mode" == true ]] && (( ! ${+merged_set[$branch]} )); then
      branch_delete_flag='-D'
    fi
    git branch "$branch_delete_flag" -- "$branch"
  done

  print -r -- "‚úÖ Deleted merged branches."
}

# --- END git/tools/git-branch-cleanup.zsh

# --- BEGIN git/tools/git-commit.zsh
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Git commit helpers
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if command -v safe_unalias >/dev/null; then
  safe_unalias \
    git-commit-to-stash \
    git-commit-context
fi

# _git_commit_confirm <prompt>
# Prompt for y/N confirmation (returns 0 only on "y"/"Y").
# Usage: _git_commit_confirm <prompt>
_git_commit_confirm() {
  emulate -L zsh

  typeset prompt="${1-}"
  [[ -n "$prompt" ]] || return 1
  shift || true

  print -n -r -- "$prompt"

  typeset confirm=''
  IFS= read -r confirm
  [[ "$confirm" == [yY] ]]
}

# _git_commit_confirm_or_abort <prompt>
# Prompt for confirmation; print "Aborted" and return non-zero on decline.
# Usage: _git_commit_confirm_or_abort <prompt>
_git_commit_confirm_or_abort() {
  _git_commit_confirm "$@" && return 0
  print "üö´ Aborted"
  return 1
}

# git-commit-to-stash [commit]
# Convert a commit into a stash entry (commit ‚Üí stash); optionally drop it from history.
# Usage: git-commit-to-stash [commit]
# Notes:
# - Default target is `HEAD`.
# - Captures the commit's patch (parent..commit), not the current working tree.
# - Merge commits: uses first parent (prompts).
# Safety:
# - Dropping a pushed commit rewrites history and may require force push.
git-commit-to-stash() {
  emulate -L zsh
  setopt pipe_fail

  typeset commit_ref='' commit_sha='' parent_sha='' branch_name='' subject=''
  typeset stash_msg='' stash_sha=''
  typeset upstream='' ref_upstream='' merge_parents_count=''

  # ‚îÄ‚îÄ Safety: ensure we are inside a Git repository ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    print "‚ùå Not a git repository."
    return 1
  fi

  # Target commit (default HEAD)
  commit_ref="${1:-HEAD}"

  # Resolve commit SHA
  commit_sha=$(git rev-parse --verify "${commit_ref}^{commit}" 2>/dev/null)
  if [[ -z "$commit_sha" ]]; then
    print "‚ùå Cannot resolve commit: $commit_ref"
    return 1
  fi

  # Get parent SHA (handle root commit: no parent)
  parent_sha=$(git rev-parse --verify "${commit_sha}^" 2>/dev/null)
  if [[ -z "$parent_sha" ]]; then
    print "‚ùå Commit $commit_sha has no parent (root commit)."
    print "üß† Converting a root commit to stash is ambiguous; aborting."
    return 1
  fi

  # Detect merge commit (multiple parents) and warn
  merge_parents_count=$(git rev-list --parents -n 1 "$commit_sha" | wc -w | tr -d ' ')
  # Output format: <commit> <p1> <p2> ... so count > 2 means multiple parents
  if (( merge_parents_count > 2 )); then
    print "‚ö†Ô∏è  Target commit is a merge commit (multiple parents)."
    print "üß† This tool will use the FIRST parent to compute the patch: ${commit_sha}^1..${commit_sha}"
    _git_commit_confirm_or_abort "‚ùì Proceed? [y/N] " || return 1
    parent_sha=$(git rev-parse --verify "${commit_sha}^1" 2>/dev/null) || return 1
  fi

  # Gather context for stash message
  branch_name=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) || branch_name="(unknown)"
  subject=$(git log -1 --pretty=%s "$commit_sha" 2>/dev/null) || subject="(no subject)"

  # Create a descriptive stash message (includes commit + parent for traceability)
  # Format example:
  #   c2s: commit=abcd123 parent=beef456 branch=feature/x "Refactor parser"
  stash_msg="c2s: commit=${commit_sha[1,7]} parent=${parent_sha[1,7]} branch=${branch_name} \"${subject}\""

  print "üßæ Convert commit ‚Üí stash"
  print "   Commit : $(git log -1 --oneline "$commit_sha")"
  print "   Parent : ${parent_sha[1,7]}"
  print "   Branch : $branch_name"
  print "   Message: $stash_msg"
  print ""
  print "This will:"
  print "  1) Create a stash entry containing the patch: ${parent_sha[1,7]}..${commit_sha[1,7]}"
  print "  2) Optionally drop the commit from branch history by resetting to parent."
  _git_commit_confirm_or_abort "‚ùì Proceed to create stash? [y/N] " || return 1

  # ‚îÄ‚îÄ Create stash entry for the commit's patch ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  #
  # We want a stash representing the diff parent..commit, regardless of the current
  # working tree state.
  #
  # Note: `git stash create [<message>]` only snapshots the *current* index/worktree.
  # It cannot directly "stash a commit". To avoid touching the working tree, we
  # synthesize a minimal stash-like commit via `git commit-tree` and then store it
  # via `git stash store`.
  #
  # Stash shape (minimal):
  # - WIP commit tree = <commit_sha>^{tree}
  #   parents:
  #     - base commit  = <parent_sha>
  #     - index commit = synthetic (tree = <parent_sha>^{tree}, parent = <parent_sha>)
  typeset base_tree='' commit_tree='' index_commit='' wip_commit=''
  base_tree=$(git rev-parse --verify "${parent_sha}^{tree}" 2>/dev/null) || base_tree=""
  commit_tree=$(git rev-parse --verify "${commit_sha}^{tree}" 2>/dev/null) || commit_tree=""
  if [[ -n "$base_tree" && -n "$commit_tree" ]]; then
    index_commit=$(git commit-tree "$base_tree" -p "$parent_sha" -m "index on ${branch_name}: ${stash_msg}" 2>/dev/null) || index_commit=""
    if [[ -n "$index_commit" ]]; then
      wip_commit=$(git commit-tree "$commit_tree" -p "$parent_sha" -p "$index_commit" -m "$stash_msg" 2>/dev/null) || wip_commit=""
    fi
  fi

  stash_sha="$wip_commit"

  if [[ -z "$stash_sha" ]]; then
    print "‚ö†Ô∏è  Failed to synthesize stash object without touching worktree."
    print "üß† Fallback would require touching the working tree."
    _git_commit_confirm_or_abort "‚ùì Fallback by temporarily checking out parent and applying patch (will modify worktree)? [y/N] " || return 1

    # ‚îÄ‚îÄ Fallback (touches worktree): store patch into stash via temp apply ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Preconditions: require clean worktree to avoid mixing changes
    if [[ -n "$(git status --porcelain 2>/dev/null)" ]]; then
      print "‚ùå Working tree is not clean; fallback requires clean state."
      print "üß† Commit/stash your current changes first, then retry."
      return 1
    fi

    # Save where we are
    typeset current_head=''
    current_head=$(git rev-parse HEAD 2>/dev/null) || return 1

    # Move to parent in detached HEAD to apply patch cleanly
    if ! git checkout --detach "$parent_sha" >/dev/null 2>&1; then
      print "‚ùå Failed to checkout parent for fallback."
      return 1
    fi

    # Apply patch (parent..commit) to working tree
    if ! git cherry-pick -n "$commit_sha" >/dev/null 2>&1; then
      print "‚ùå Failed to apply commit patch in fallback mode."
      print "üß† Attempting to restore original HEAD."
      git cherry-pick --abort >/dev/null 2>&1
      git checkout "$current_head" >/dev/null 2>&1
      return 1
    fi

    # Now stash the applied changes (includes tracked changes; can add -u if desired)
    if ! git stash push -m "$stash_msg" >/dev/null 2>&1; then
      print "‚ùå Failed to stash changes in fallback mode."
      git reset --hard >/dev/null 2>&1
      git checkout "$current_head" >/dev/null 2>&1
      return 1
    fi

    # Restore original HEAD
    git reset --hard >/dev/null 2>&1
    git checkout "$current_head" >/dev/null 2>&1

    print "‚úÖ Stash created (fallback): $(git stash list -1)"
  else
    # Store the created stash object into stash list with message
    if ! git stash store -m "$stash_msg" "$stash_sha" >/dev/null 2>&1; then
      print "‚ùå Failed to store stash object."
      return 1
    fi
    print "‚úÖ Stash created: $(git stash list -1)"
  fi

  # ‚îÄ‚îÄ Optional: drop the commit from history by resetting current branch ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  #
  # This is only safe if:
  # - The commit is at the tip of current branch (HEAD), OR you explicitly want rewrite.
  # We keep it conservative: only offer automatic drop when commit_ref == HEAD.
  if [[ "$commit_ref" != "HEAD" && "$commit_sha" != "$(git rev-parse HEAD 2>/dev/null)" ]]; then
    print "‚ÑπÔ∏è  Not dropping commit automatically because target is not HEAD."
    print "üß† If you want to remove it, do so explicitly (e.g., interactive rebase) after verifying stash."
    return 0
  fi

  print ""
  print "Optional: drop the commit from current branch history?"
  print "  This would run: git reset --hard ${parent_sha[1,7]}"
  print "  (Your work remains in stash; untracked files are unaffected.)"
  if ! _git_commit_confirm "‚ùì Drop commit from history now? [y/N] "; then
    print "‚úÖ Done. Commit kept; stash saved."
    return 0
  fi

  # Extra warning if commit appears reachable from upstream (heuristic)
  upstream=$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}" 2>/dev/null)
  # If commit is an ancestor of upstream or equal/reachable, it was likely pushed
  if [[ -n "$upstream" ]] && git merge-base --is-ancestor "$commit_sha" "$upstream" 2>/dev/null; then
    print "‚ö†Ô∏è  This commit appears to be reachable from upstream ($upstream)."
    print "üß® Dropping it rewrites history and may require force push; it can affect others."
    if ! _git_commit_confirm "‚ùì Still drop it? [y/N] "; then
      print "‚úÖ Done. Commit kept; stash saved."
      return 0
    fi
  fi

  if ! _git_commit_confirm "‚ùì Final confirmation: run 'git reset --hard ${parent_sha[1,7]}'? [y/N] "; then
    print "‚úÖ Done. Commit kept; stash saved."
    return 0
  fi

  if ! git reset --hard "$parent_sha"; then
    print "‚ùå Failed to reset branch to parent."
    print "üß† Your stash is still saved. You can manually recover the commit via reflog if needed."
    return 1
  fi

  print "‚úÖ Commit dropped from history. Your work is in stash:"
  print "   $(git stash list -1)"
}

# git-commit-context [--stdout|--both] [--no-color]
# Generate a Markdown commit context for the current staged changes.
# Usage: git-commit-context [--stdout|--both] [--no-color] [--include <path/glob>]
# Notes:
# - Includes: scope tree (`git-scope staged`), staged diff, and per-file staged contents (index version).
# - Lockfile contents are hidden by default; use --include to show selected files.
# - Default copies to clipboard via `set_clipboard`; use `--stdout` to print only.
# - `--no-color` also applies when `NO_COLOR` is set.
git-commit-context () {
  emulate -L zsh
  setopt pipe_fail local_traps

  typeset tmpfile='' diff='' scope='' contents='' mode='clipboard'
  typeset no_color=false
  typeset arg=''
  typeset include_arg=''
  typeset -a include_patterns=()
  typeset -a extra_args=()

  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    print -u2 -r -- "‚ùå Not a git repository."
    return 1
  fi

  while [[ $# -gt 0 ]]; do
    arg="${1-}"
    case "$arg" in
      --stdout|-p|--print)
        mode="stdout"
        ;;
      --both)
        mode="both"
        ;;
      --no-color|no-color)
        no_color=true
        ;;
      --include)
        shift
        include_arg="${1-}"
        if [[ -z "$include_arg" ]]; then
          print -u2 -r -- "‚ùå Missing value for --include"
          return 2
        fi
        include_patterns+=("$include_arg")
        ;;
      --include=*)
        include_patterns+=("${arg#*=}")
        ;;
      --help|-h)
        print -r -- "Usage: git-commit-context [--stdout|--both] [--no-color] [--include <path/glob>]"
        print -r -- "  --stdout   Print commit context to stdout only"
        print -r -- "  --both     Print to stdout and copy to clipboard"
        print -r -- "  --no-color Disable ANSI colors (also via NO_COLOR)"
        print -r -- "  --include  Show full content for selected paths (repeatable)"
        return 0
        ;;
      *)
        extra_args+=("$arg")
        ;;
    esac
    shift
  done

  diff="$(git diff --cached --no-color)"

  if (( ${#extra_args[@]} > 0 )); then
    print -u2 -r -- "‚ö†Ô∏è  Ignoring unknown arguments: ${extra_args[*]}"
  fi

  if [[ -z "$diff" ]]; then
    printf "‚ö†Ô∏è  No staged changes to record\n" >&2
    return 1
  fi

  typeset -a scope_args=(staged)
  if [[ "$no_color" == true || -n "${NO_COLOR-}" ]]; then
    scope_args+=(--no-color)
  fi
  scope="$(git-scope "${scope_args[@]}" | sed 's/\x1b\[[0-9;]*m//g')"

  tmpfile="$(mktemp -t commit-context.md.XXXXXX)"
  trap '[[ -n "${tmpfile-}" ]] && rm -f "${tmpfile-}" >/dev/null 2>&1' EXIT

  contents="$(
    git -c core.quotepath=false diff --cached --name-status -z | while IFS= read -r -d '' fstatus; do
      typeset file='' newfile=''
      typeset display_path='' content_path='' numstat='' added='' deleted=''
      typeset include_content=false
      typeset lockfile=false
      typeset binary_file=false
      typeset blob_ref='' blob_size='' blob_type=''

      if [[ -z "$fstatus" ]]; then
        continue
      fi

      case "$fstatus" in
        R*|C*)
          IFS= read -r -d '' file || break
          IFS= read -r -d '' newfile || break
          ;;
        *)
          IFS= read -r -d '' file || break
          ;;
      esac

      display_path="$file"
      content_path="$file"

      if [[ -n "$newfile" ]]; then
        display_path="${file} -> ${newfile}"
        content_path="$newfile"
      fi

      for include_pattern in "${include_patterns[@]}"; do
        if [[ -n "$include_pattern" && "$content_path" == ${~include_pattern} ]]; then
          include_content=true
          break
        fi
      done

      case "${content_path:t}" in
        yarn.lock|package-lock.json|pnpm-lock.yaml|bun.lockb|bun.lock|npm-shrinkwrap.json)
          lockfile=true
          ;;
        *)
          ;;
      esac

      printf "### %s (%s)\n\n" "$display_path" "$fstatus"

      if [[ "$fstatus" == "D" ]]; then
        blob_ref="HEAD:$file"
      else
        blob_ref=":$content_path"
      fi

      numstat="$(git diff --cached --numstat -- "$content_path" 2>/dev/null | head -n 1)"
      if [[ -n "$numstat" ]]; then
        IFS=$' \t' read -r added deleted _ <<< "$numstat"
        if [[ "$added" == "-" || "$deleted" == "-" ]]; then
          binary_file=true
        fi
      fi

      if [[ "$binary_file" == false && -n "$blob_ref" && -x "$(command -v file)" ]]; then
        if git cat-file -e "$blob_ref" 2>/dev/null; then
          blob_type="$(git cat-file -p "$blob_ref" 2>/dev/null | head -c 8192 | file -b --mime - 2>/dev/null)"
          if [[ "$blob_type" == *"charset=binary"* ]]; then
            binary_file=true
          fi
        fi
      fi

      if [[ "$binary_file" == true ]]; then
        blob_size="$(git cat-file -s "$blob_ref" 2>/dev/null)"
        printf "[Binary file content hidden]\n\n"
        if [[ -n "$blob_size" ]]; then
          printf "Size: %s bytes\n" "$blob_size"
        fi
        if [[ -n "$blob_type" ]]; then
          printf "Type: %s\n" "$blob_type"
        fi
        printf "\n"
        continue
      fi

      if [[ "$lockfile" == true && "$include_content" != true ]]; then
        printf "[Lockfile content hidden]\n\n"
        if [[ -n "$added" && -n "$deleted" && "$added" != "-" && "$deleted" != "-" ]]; then
          printf "Summary: +%s -%s\n" "$added" "$deleted"
        fi
        printf "Tip: use --include %s to show full content\n\n" "$content_path"
        continue
      fi

      if [[ "$fstatus" == "D" ]]; then
        if git cat-file -e "HEAD:$file" 2>/dev/null; then
          printf "[Deleted file, showing HEAD version]\n\n"
          printf '```ts\n'
          git show "HEAD:$file" 2>/dev/null || printf '[HEAD version not found]\n'
          printf '```\n\n'
        else
          printf "[Deleted file, no HEAD version found]\n\n"
        fi
      elif [[ "$fstatus" == "A" || "$fstatus" == "M" || "$fstatus" == R* || "$fstatus" == C* ]]; then
        printf '```ts\n'
        git show :"$content_path" 2>/dev/null || printf '[Index version not found]\n'
        printf '```\n\n'
      else
        printf "[Unhandled status: %s]\n\n" "$fstatus"
      fi
    done
  )"

  printf "%s\n" "# Commit Context

## Input expectations

- Full-file reads are not required for commit message generation.
- Base the message on staged diff, scope tree, and staged (index) version content.

---

## üìÇ Scope and file tree:

\`\`\`text
$scope
\`\`\`

## üìÑ Git staged diff:

\`\`\`diff
$diff
\`\`\`

## üìö Staged file contents (index version):

$contents" > "$tmpfile"

  if [[ "$mode" == "stdout" ]]; then
    command cat "$tmpfile"
    return 0
  fi

  if [[ "$mode" == "both" ]]; then
    command cat "$tmpfile"
  fi

  command cat "$tmpfile" | set_clipboard

  if [[ "$mode" == "clipboard" ]]; then
    printf "‚úÖ Commit context copied to clipboard with:\n"
    printf "  ‚Ä¢ Diff\n"
    printf "  ‚Ä¢ Scope summary (via git-scope staged)\n"
    printf "  ‚Ä¢ Staged file contents (index version)\n"
  fi
}

# --- END git/tools/git-commit.zsh

# --- BEGIN git/git-scope.zsh
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Aliases and Unalias
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if command -v safe_unalias >/dev/null; then
  safe_unalias gs gsc gst
fi

# gs
# Alias of `git-scope`.
# Usage: gs <command> [args...]
alias gs='git-scope'

# gsc
# Alias of `git-scope commit`.
# Usage: gsc <commit-ish> [--parent <n>] [-p|--print]
alias gsc='git-scope commit'

# gst
# Alias of `git-scope tracked`.
# Usage: gst [prefix...]
alias gst='git-scope tracked'

_git_scope_no_color=false

# _git_scope_kind_color <A|M|D|U|->
# Return ANSI color code for a file change kind.
# Usage: _git_scope_kind_color <A|M|D|U|->
_git_scope_kind_color() {
  if [[ "$_git_scope_no_color" == true ]]; then
    return 0
  fi

  case "$1" in
    A) printf '\033[38;5;66m'  ;;  # Added    ‚Üí #3d6f6f (Delta plus-style)
    M) printf '\033[38;5;110m' ;;  # Modified ‚Üí #add6ff (Delta file-style)
    D) printf '\033[38;5;95m'  ;;  # Deleted  ‚Üí #5a3e39 (Delta minus-style)
    U) printf '\033[38;5;110m' ;;  # Unknown  ‚Üí fallback Owl Blue (#82aaff)
    -) printf '\033[0m'        ;;  # Reset
    *) printf '\033[38;5;110m' ;;  # Fallback
  esac
}

# _git_scope_color_reset
# Print ANSI reset code (no-op when no-color is enabled).
# Usage: _git_scope_color_reset
_git_scope_color_reset() {
  if [[ "$_git_scope_no_color" == true ]]; then
    return 0
  fi

  printf '\033[0m'
}

# _git_scope_render_tree <newline_separated_paths>
# Render a directory tree from a list of file paths.
# Usage: _git_scope_render_tree <newline_separated_paths>
_git_scope_render_tree() {
  typeset -a file_list=("${(@f)}$1")

  if [[ "${#file_list[@]}" -eq 0 ]]; then
    printf "‚ö†Ô∏è No files to render as tree\n"
    return 1
  fi

  printf "\nüìÇ Directory tree:\n"

  typeset -a tree_args=(--fromfile)
  typeset strip_color=false
  if [[ "$_git_scope_no_color" == true ]]; then
    strip_color=true
  else
    tree_args+=(-C)
  fi

  if [[ "$strip_color" == true ]]; then
    printf "%s\n" "${file_list[@]}" | awk -F/ '{
      path=""
      for(i=1;i<NF;i++) {
        path = (path ? path "/" $i : $i)
        print path
      }
      print $0
    }' | sort -u | command tree "${tree_args[@]}" | sed 's/\x1b\[[0-9;]*m//g'
  else
    printf "%s\n" "${file_list[@]}" | awk -F/ '{
      path=""
      for(i=1;i<NF;i++) {
        path = (path ? path "/" $i : $i)
        print path
      }
      print $0
    }' | sort -u | command tree "${tree_args[@]}"
  fi
}


# _git_scope_render_with_type <name_status_lines>
# Render `git diff --name-status`-style lines and show a directory tree.
# Usage: _git_scope_render_with_type <name_status_lines>
_git_scope_render_with_type() {
  typeset input="$1"

  if [[ -z "$input" ]]; then
    printf "‚ö†Ô∏è  No matching files\n"
    return 1
  fi

  typeset color_reset="$(_git_scope_color_reset)"
  typeset -a files=()

  printf "\nüìÑ Changed files:\n"

  while IFS=$'\t' read -r kind src dest; do
    [[ -z "$src" ]] && continue

    typeset display_path="$src"
    typeset file_path="$src"
    if [[ ( "$kind" == R* || "$kind" == C* ) && -n "$dest" ]]; then
      display_path="${src} -> ${dest}"
      file_path="$dest"
    fi

    files+=("$file_path")
    typeset color="$(_git_scope_kind_color "$kind")"
    printf "  %b‚ûî [%s] %s%b\n" "$color" "$kind" "$display_path" "$color_reset"
  done <<< "$input"

  _git_scope_render_tree "${(F)files}"

  if [[ "$_git_scope_should_print" == true ]]; then
    printf "\nüì¶ Printing file contents:\n"
    for file in "${files[@]}"; do
      print_file_content "$file"
      printf "\n"
    done
  fi
}


# _git_scope_collect <mode> [args...]
# Collect file lists for `git-scope` subcommands.
# Usage: _git_scope_collect <tracked|staged|unstaged|all|untracked|commit> [args...]
_git_scope_collect() {
  typeset mode="$1"
  (( $# > 0 )) && shift

  typeset -a args=()
  _git_scope_should_print=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -p|--print) _git_scope_should_print=true ;;
      *) args+=("$1") ;;
    esac
    (( $# > 0 )) && shift
  done

  case "$mode" in
    staged)
      git -c core.quotepath=false diff --cached --name-status --diff-filter=ACMRTUXB ;;
    unstaged)
      git -c core.quotepath=false diff --name-status --diff-filter=ACMRTUXB ;;
    all)
      printf "%s\n%s" \
        "$(git -c core.quotepath=false diff --cached --name-status --diff-filter=ACMRTUXB)" \
        "$(git -c core.quotepath=false diff --name-status --diff-filter=ACMRTUXB)" \
        | grep -v '^$' | sort -u ;;
    tracked)
      typeset -a prefixes=("${args[@]}")
      typeset files all_filtered
      files=$(git -c core.quotepath=false ls-files)
      if [[ ${#prefixes[@]} -gt 0 ]]; then
        for prefix in "${prefixes[@]}"; do
          clean_prefix="${prefix%/}"
          if [[ -d "$clean_prefix" ]]; then
            all_filtered+=$'\n'$(printf '%s\n' "$files" | grep "^${clean_prefix}/")
          elif [[ -f "$clean_prefix" ]]; then
            all_filtered+=$'\n'$(printf '%s\n' "$files" | grep -x "$clean_prefix")
          else
            all_filtered+=$'\n'$(printf '%s\n' "$files" | grep "^${clean_prefix}")
          fi
        done
        files="$(printf '%s\n' "$all_filtered" | grep -v '^$' | sort -u)"
      fi
      printf '%s\n' "$files" | while IFS= read -r f; do
        [[ -n "$f" ]] && printf "-\t%s\n" "$f"
      done ;;
    untracked)
      git -c core.quotepath=false ls-files --others --exclude-standard | while IFS= read -r f; do
        [[ -n "$f" ]] && printf "U\t%s\n" "$f"
      done ;;
    commit)
      typeset commit="${args[1]}"
      git -c core.quotepath=false show --pretty=format: --name-status "$commit" ;;
    *)
      printf "‚ö†Ô∏è Unknown collect mode: %s\n" "$mode" >&2
      return 1 ;;
  esac
}

# print_file_content <path>
# Print file contents from working tree, or fallback to `HEAD:<path>` when missing locally.
# Usage: print_file_content <path>
print_file_content() {
  typeset file="$1"

  if [[ -z "$file" ]]; then
    printf "‚ùó Missing file path\n"
    return 1
  fi

  if [[ -f "$file" ]]; then
    if file --mime "$file" | grep -q 'charset=binary'; then
      printf "üìÑ %s (binary file in working tree)\n" "$file"
      printf "üîπ [Binary file content omitted]\n"
    else
      printf "üìÑ %s (working tree)\n" "$file"
      printf '```\n'
      cat -- "$file"
      printf '\n```\n'
    fi
  elif git cat-file -e "HEAD:$file" 2>/dev/null; then
    typeset tmp
    tmp="$(mktemp)"
    git show "HEAD:$file" > "$tmp"

    if file --mime "$tmp" | grep -q 'charset=binary'; then
      printf "üìÑ %s (binary file in HEAD)\n" "$file"
      printf "üîπ [Binary file content omitted]\n"
    else
      printf "üìÑ %s (from HEAD)\n" "$file"
      printf '```\n'
      cat -- "$tmp"
      printf '\n```\n'
    fi

    rm -f "$tmp"
  else
    printf "‚ùó File not found: %s\n" "$file"
    return 1
  fi
}

# Command handlers
# _git_scope_tracked: Handler for `git-scope tracked`.
_git_scope_tracked()   { _git_scope_render_with_type "$(_git_scope_collect tracked "$@")"; }
# _git_scope_staged: Handler for `git-scope staged`.
_git_scope_staged()    { _git_scope_render_with_type "$(_git_scope_collect staged "$@")"; }
# _git_scope_unstaged: Handler for `git-scope unstaged`.
_git_scope_unstaged()  { _git_scope_render_with_type "$(_git_scope_collect unstaged "$@")"; }
# _git_scope_all: Handler for `git-scope all`.
_git_scope_all()       { _git_scope_render_with_type "$(_git_scope_collect all "$@")"; }
# _git_scope_untracked: Handler for `git-scope untracked`.
_git_scope_untracked() { _git_scope_render_with_type "$(_git_scope_collect untracked "$@")"; }

# _git_scope_commit - Show detailed information of a git commit
#
# Unlike other git-scope commands (e.g., `staged`, `tracked`), which operate
# on the working directory or index, this command analyzes a historical commit
# and renders its metadata, commit message, changed files, and optionally
# prints the file contents if they are retrievable from HEAD or working tree.
#
# Features:
#   ‚Ä¢ Displays commit hash, author, date, and message with formatting
#   ‚Ä¢ Parses both name-status and numstat to show per-file diff counts
#   ‚Ä¢ Computes total lines added and deleted across all files
#   ‚Ä¢ Renders affected directory structure using `tree --fromfile`
#   ‚Ä¢ Supports `-p` to print file contents (text or binary placeholder)
#
# Usage:
#   git-scope commit <commit-ish> [-p]
#
# Example:
#   git-scope commit HEAD~1         # Show summary of an old commit
#   git-scope commit a1b2c3 -p      # Show and print files changed in a commit
#
# Note:
#   Internally, it isolates display output from file path data, ensuring
#   clean separation of UI and logic. It uses a temporary file to pass
#   changed file paths from the rendering function back to the dispatcher.
#
# This command is especially useful for code review, audit trails, or
# inspecting past changes in high detail.
_git_scope_commit() {
  emulate -L zsh
  setopt pipe_fail

  typeset parent_selector=''
  typeset -a positional=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --parent|-P)
        if [[ $# -lt 2 ]]; then
          printf "‚ùó --parent requires an argument\n"
          return 1
        fi
        parent_selector="$2"
        shift 2
        continue
        ;;
      --parent=*)
        parent_selector="${1#*=}"
        ;;
      -P*)
        parent_selector="${1#-P}"
        ;;
      *)
        positional+=("$1")
        ;;
    esac
    shift
  done

  typeset commit="${positional[1]}"
  if [[ -z "$commit" ]]; then
    printf "‚ùó Usage: git-scope commit <commit-hash | HEAD> [--parent <n>]\n"
    return 1
  fi

  _git_scope_print_commit_metadata "$commit"
  _git_scope_print_commit_message "$commit"
  _git_scope_render_commit_files "$commit" "$parent_selector"

  typeset -a file_list
  file_list=("${(@f)$(< /tmp/.git-scope-filelist)}")

  if [[ "$_git_scope_should_print" == true ]]; then
    printf "\nüì¶ Printing file contents:\n"
    for file in "${file_list[@]}"; do
      print_file_content "$file"
      printf "\n"
    done
  fi
}

# Print commit header info (hash, author, date)
_git_scope_print_commit_metadata() {
  typeset commit="$1"

  printf "\n"
  if [[ "$_git_scope_no_color" == true ]]; then
    git log -1 --color=never --date=format:'%Y-%m-%d %H:%M:%S %z' \
      --pretty=format:"üîñ %h %s%nüë§ %an <%ae>%nüìÖ %ad" "$commit"
  else
    git log -1 --date=format:'%Y-%m-%d %H:%M:%S %z' \
      --pretty=format:"üîñ %C(bold #82aaff)%h%C(reset) %C(#d6deeb)%s%C(reset)%nüë§ %C(#7fdbca)%an%C(reset) <%C(#d6deeb)%ae%C(reset)>%nüìÖ %C(#ecc48d)%ad%C(reset)" "$commit"
  fi
}

# Pretty print commit message body
_git_scope_print_commit_message() {
  typeset commit="$1"

  printf "\n\nüìù Commit Message:\n"
  git log -1 --pretty=format:%B "$commit" | awk '
    NR == 1 { print "   "$0; next }
    length($0) == 0 { print "" ; next } 
    { print "   "$0 }'
}

# Render file change list with color and stats
_git_scope_commit_parents() {
  emulate -L zsh
  setopt pipe_fail

  typeset commit="$1"
  typeset parents_raw=''

  typeset -ga reply=()

  parents_raw=$(git show -s --pretty=%P "$commit") || return 1
  if [[ -z "$parents_raw" ]]; then
    reply=()
    return 0
  fi

  reply=("${(@s: :)parents_raw}")
  return 0
}

# _git_scope_render_commit_files <commit> [parent_selector]
# Render changed files for a commit (supports merge commits via parent selection).
# Usage: _git_scope_render_commit_files <commit> [parent_selector]
# Notes:
# - Writes the file list to `/tmp/.git-scope-filelist` for optional printing.
_git_scope_render_commit_files() {
  emulate -L zsh
  setopt pipe_fail

  typeset commit="$1"
  typeset parent_selector="$2"
  typeset -a file_list=()
  typeset -a preface_lines=()

  typeset ns_lines='' numstat_lines=''
  typeset -A numstat_by_path=()
  typeset -a parents=()
  typeset parent_count=0
  typeset is_merge=false

  _git_scope_commit_parents "$commit"
  parents=("${reply[@]}")
  parent_count=${#parents[@]}
  (( parent_count > 1 )) && is_merge=true

  typeset selected_parent_hash=''
  typeset selected_parent_short=''
  typeset selected_index=1

  if [[ "$is_merge" == true ]]; then
    if [[ -n "$parent_selector" ]]; then
      if [[ "$parent_selector" == <-> ]]; then
        selected_index=$parent_selector
      else
        preface_lines+=("  ‚ö†Ô∏è  Invalid --parent value '${parent_selector}' ‚Äî falling back to parent #1")
        selected_index=1
      fi
    fi

    if (( selected_index < 1 || selected_index > parent_count )); then
      preface_lines+=("  ‚ö†Ô∏è  Parent index ${selected_index} out of range (1-${parent_count}) ‚Äî falling back to parent #1")
      selected_index=1
    fi

    selected_parent_hash="$parents[$selected_index]"
    selected_parent_short=$(git rev-parse --short "$selected_parent_hash" 2>/dev/null)

    ns_lines=$(git -c core.quotepath=false diff --name-status "$selected_parent_hash" "$commit")
    numstat_lines=$(git -c core.quotepath=false diff --numstat "$selected_parent_hash" "$commit")

    if [[ -z "$ns_lines" ]]; then
      printf "\nüìÑ Changed files:\n"
      printf "  ‚ÑπÔ∏è  Merge commit vs parent #%d (%s) has no file-level changes\n" "$selected_index" "${selected_parent_short:-$selected_parent_hash}"
      : > /tmp/.git-scope-filelist
      return
    fi
  else
    ns_lines=$(git show --pretty=format: --name-status "$commit")
    numstat_lines=$(git show --pretty=format: --numstat "$commit")

    if [[ -z "$ns_lines" || -z "$numstat_lines" ]]; then
      printf "\nüìÑ Changed files:\n"
      printf "  ‚ÑπÔ∏è  No file-level changes recorded for this commit\n"
      : > /tmp/.git-scope-filelist
      return
    fi
  fi

  typeset total_add=0 total_del=0
  typeset color_reset="$(_git_scope_color_reset)"

  printf "\nüìÑ Changed files:\n"

  for line in "${preface_lines[@]}"; do
    [[ -n "$line" ]] && printf "%s\n" "$line"
  done

  if [[ "$is_merge" == true ]]; then
    printf "  ‚ÑπÔ∏è  Merge commit with %d parents ‚Äî showing diff against parent #%d (%s)\n" "$parent_count" "$selected_index" "${selected_parent_short:-$selected_parent_hash}"
  fi

  while IFS=$'\t' read -r add del raw_path; do
    [[ -z "$raw_path" ]] && continue

    typeset canonical_path="$raw_path"
    if [[ "$raw_path" == *"=>"* ]]; then
      if [[ "$raw_path" == *"{"* && "$raw_path" == *"}"* ]]; then
        typeset prefix="${raw_path%%\{*}"
        typeset after_open="${raw_path#*\{}"
        typeset inside="${after_open%%\}*}"
        typeset suffix="${after_open#*\}}"

        typeset new_part="${inside##*=> }"
        if [[ "$new_part" == "$inside" ]]; then
          new_part="${inside##*=>}"
          new_part="${new_part## }"
        fi

        canonical_path="${prefix}${new_part}${suffix}"
      else
        canonical_path="${raw_path##*=> }"
        if [[ "$canonical_path" == "$raw_path" ]]; then
          canonical_path="${raw_path##*=>}"
          canonical_path="${canonical_path## }"
        fi
      fi
    fi

    numstat_by_path["$canonical_path"]="${add}"$'\t'"${del}"
  done <<< "$numstat_lines"

  while IFS=$'\t' read -r kind src dest; do
    [[ -z "$src" ]] && continue

    typeset display_path="$src"
    typeset file_path="$src"
    if [[ ( "$kind" == R* || "$kind" == C* ) && -n "$dest" ]]; then
      display_path="${src} -> ${dest}"
      file_path="$dest"
    fi

    file_list+=("$file_path")

    typeset add="-"
    typeset del="-"
    typeset stats="${numstat_by_path["$file_path"]-}"
    if [[ -n "$stats" ]]; then
      add="${stats%%$'\t'*}"
      del="${stats#*$'\t'}"
      [[ "$add" != "-" ]] && total_add=$((total_add + add))
      [[ "$del" != "-" ]] && total_del=$((total_del + del))
    fi

    typeset color="$(_git_scope_kind_color "$kind")"
    printf "  %b‚û§ [%s] %s  [+%s / -%s]%b\n" "$color" "$kind" "$display_path" "$add" "$del" "$color_reset"
  done <<< "$ns_lines"

  printf "\n  üìä Total: +%d / -%d\n" "$total_add" "$total_del"
  _git_scope_render_tree "${(F)file_list}"

  printf "%s\n" "${file_list[@]}" > /tmp/.git-scope-filelist
}

# git-scope: Working tree/commit introspection (dispatcher)
# Usage: git-scope <command> [args]
# - Subcommands: tracked, staged, unstaged, all, untracked, commit <id>
# - Flags: -p|--print prints file contents where applicable (e.g., commit)
# - Runs inside a Git repo; renders trees, diffs, and summaries
git-scope() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    printf "‚ö†Ô∏è Not a Git repository. Run this command inside a Git project.\n"
    return 1
  fi

  _git_scope_no_color=false
  if [[ -n "${NO_COLOR-}" ]]; then
    _git_scope_no_color=true
  fi

  typeset -a filtered_args=()
  for arg in "$@"; do
    if [[ "$arg" == "--no-color" || "$arg" == "no-color" ]]; then
      _git_scope_no_color=true
    else
      filtered_args+=("$arg")
    fi
  done

  typeset sub="${filtered_args[1]:-help}"
  (( ${#filtered_args[@]} > 0 )) && filtered_args=("${filtered_args[@]:1}")

  # Detect -p flag (print file content)
  _git_scope_should_print=false
  typeset -a args=()
  for arg in "${filtered_args[@]}"; do
    if [[ "$arg" == "-p" || "$arg" == "--print" ]]; then
      _git_scope_should_print=true
    else
      args+=("$arg")
    fi
  done

  case "$sub" in
    tracked)
      _git_scope_tracked "${args[@]}" ;;
    staged)
      _git_scope_staged "${args[@]}" ;;
    unstaged)
      _git_scope_unstaged "${args[@]}" ;;
    all)
      _git_scope_all "${args[@]}" ;;
    untracked)
      _git_scope_untracked "${args[@]}" ;;
    commit)
      _git_scope_commit "${args[@]}" ;;
    help|-h|--help|"")
      printf "%s\n" "Usage: git-scope <command> [args]"
      printf "\n"
      printf "%s\n" "Commands:"
      printf "  %-16s  %s\n" \
        tracked        "Show files tracked by Git (prefix filter optional)" \
        staged         "Show files staged for commit" \
        unstaged       "Show modified files not yet staged" \
        all            "Show all changes (staged and unstaged)" \
        untracked      "Show untracked files"
      printf "  %-16s  %s\n" "commit <id>" "Show commit details (use -p to print content)"
      printf "\n"
      printf "%s\n" "Options:"
      printf "  %-16s  %s\n" "-p, --print" "Print file contents where applicable (e.g., commit)"
      printf "  %-16s  %s\n" "--no-color" "Disable ANSI colors (also via NO_COLOR)"
      ;;
    *)
      printf "‚ö†Ô∏è Unknown subcommand: '%s'\n" "$sub"
      return 1 ;;
  esac
}

# --- END git/git-scope.zsh

# --- BEGIN git/git-tools.zsh
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Aliases and Unalias
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if command -v safe_unalias >/dev/null; then
  safe_unalias \
    gr grs grm grh \
    gbh gbc gdb gdbs \
    gcc gdc \
    git-tools
fi

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Git operation aliases
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# gr
# Alias of `git reset` (commonly used to unstage paths).
# Usage: gr [args...]
alias gr='git reset'

# grs [N]
# Alias of `git-reset-soft`.
# Usage: grs [N]
alias grs='git-reset-soft'

# grm [N]
# Alias of `git-reset-mixed`.
# Usage: grm [N]
alias grm='git-reset-mixed'

# grh [N]
# Alias of `git-reset-hard` (DANGEROUS).
# Usage: grh [N]
# Safety:
# - Discards tracked staged/unstaged changes; untracked files are NOT removed.
alias grh='git-reset-hard'

# gbh
# Alias of `git-back-head`.
# Usage: gbh
alias gbh='git-back-head'

# gbc
# Alias of `git-back-checkout`.
# Usage: gbc
alias gbc='git-back-checkout'

# gdb
# Alias of `git-delete-merged-branches`.
# Usage: gdb [-b|--base <ref>] [-s|--squash]
# Safety:
# - Deletes local branches after confirmation; review the list before proceeding.
alias gdb='git-delete-merged-branches'

# gdbs
# Alias of `gdb --squash`.
# Usage: gdbs [-b|--base <ref>]
# Safety:
# - Deletes local branches after confirmation; review the list before proceeding.
alias gdbs='gdb --squash'

# gcc
# Alias of `git-commit-context`.
# Usage: gcc [--stdout|--both] [--no-color]
alias gcc='git-commit-context'

# gdc
# Alias of `git-copy-staged`.
# Usage: gdc [--stdout|--both]
alias gdc='git-copy-staged'

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Git tools CLI entrypoint
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# _git_tools_usage
# Print top-level usage for `git-tools`.
# Usage: _git_tools_usage
_git_tools_usage() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  print -r -- "Usage:"
  print -r -- "  git-tools <group> <command> [args]"
  print -r --
  print -r -- "Groups:"
  print -r -- "  utils    zip | copy-staged | root | commit-hash"
  print -r -- "  reset    soft | mixed | hard | undo | back-head | back-checkout | remote"
  print -r -- "  commit   context | to-stash"
  print -r -- "  branch   cleanup"
  print -r --
  print -r -- "Help:"
  print -r -- "  git-tools help"
  print -r -- "  git-tools <group> help"
  print -r --
  print -r -- "Examples:"
  print -r -- "  git-tools utils zip"
  print -r -- "  git-tools reset hard 3"
  return 0
}

# _git_tools_group_usage <group>
# Print `git-tools <group>` usage.
# Usage: _git_tools_group_usage <group>
_git_tools_group_usage() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  typeset group="${1-}"

  case "$group" in
    utils)
      print -r -- "Usage: git-tools utils <command> [args]"
      print -r -- "  zip | copy-staged | root | commit-hash"
      ;;
    reset)
      print -r -- "Usage: git-tools reset <command> [args]"
      print -r -- "  soft | mixed | hard | undo | back-head | back-checkout | remote"
      ;;
    commit)
      print -r -- "Usage: git-tools commit <command> [args]"
      print -r -- "  context | to-stash"
      ;;
    branch)
      print -r -- "Usage: git-tools branch <command> [args]"
      print -r -- "  cleanup"
      ;;
    *)
      print -u2 -r -- "Unknown group: $group"
      _git_tools_usage
      return 2
      ;;
  esac
}

# git-tools <group> <command> [args...]
# Dispatcher for git helper subcommands.
# Usage: git-tools <group> <command> [args...]
# Notes:
# - Groups: utils, reset, commit, branch
# - Run `git-tools help` or `git-tools <group> help` for subcommand lists.
# Examples:
#   git-tools reset hard 3
git-tools() {
  emulate -L zsh
  setopt pipe_fail err_return nounset

  typeset group="${1-}"
  typeset cmd="${2-}"

  case "$group" in
    ''|-h|--help|help|list)
      _git_tools_usage
      return 0
      ;;
    *)
      ;;
  esac

  if [[ -z "$cmd" || "$cmd" == "-h" || "$cmd" == "--help" || "$cmd" == "help" ]]; then
    _git_tools_group_usage "$group"
    return $?
  fi

  shift 2

  case "$group" in
    utils)
      case "$cmd" in
        zip)
          git-zip "$@"
          ;;
        copy-staged|copy)
          git-copy-staged "$@"
          ;;
        root)
          git-root "$@"
          ;;
        commit-hash|hash)
          get_commit_hash "$@"
          ;;
        *)
          print -u2 -r -- "Unknown utils command: $cmd"
          _git_tools_group_usage "$group"
          return 2
          ;;
      esac
      ;;
    reset)
      case "$cmd" in
        soft)
          git-reset-soft "$@"
          ;;
        mixed)
          git-reset-mixed "$@"
          ;;
        hard)
          git-reset-hard "$@"
          ;;
        undo)
          git-reset-undo "$@"
          ;;
        back-head)
          git-back-head "$@"
          ;;
        back-checkout)
          git-back-checkout "$@"
          ;;
        remote)
          git-reset-remote "$@"
          ;;
        *)
          print -u2 -r -- "Unknown reset command: $cmd"
          _git_tools_group_usage "$group"
          return 2
          ;;
      esac
      ;;
    commit)
      case "$cmd" in
        context)
          git-commit-context "$@"
          ;;
        to-stash|stash)
          git-commit-to-stash "$@"
          ;;
        *)
          print -u2 -r -- "Unknown commit command: $cmd"
          _git_tools_group_usage "$group"
          return 2
          ;;
      esac
      ;;
    branch)
      case "$cmd" in
        cleanup|delete-merged)
          git-delete-merged-branches "$@"
          ;;
        *)
          print -u2 -r -- "Unknown branch command: $cmd"
          _git_tools_group_usage "$group"
        return 2
        ;;
      esac
      ;;
    *)
      print -u2 -r -- "Unknown group: $group"
      _git_tools_usage
      return 2
      ;;
  esac
}

# --- END git/git-tools.zsh

if ! typeset -f git-tools >/dev/null 2>&1; then
  print -u2 -r -- "‚ùå missing function: git-tools"
  exit 1
fi

git-tools "$@"
